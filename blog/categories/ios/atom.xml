<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 王若风的小窝]]></title>
  <link href="http://wangruofeng.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wangruofeng.github.io/"/>
  <updated>2016-01-13T04:39:41+08:00</updated>
  <id>http://wangruofeng.github.io/</id>
  <author>
    <name><![CDATA[Ace]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[优雅处理UIImage图片旋转]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/you-ya-chu-li-uiimagetu-pian-xuan-zhuan/"/>
    <updated>2016-01-13T04:38:49+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/you-ya-chu-li-uiimagetu-pian-xuan-zhuan</id>
    <content type="html"><![CDATA[<h2>UIImag构造方式</h2>

<p>UIImag构造方式大致有4种方式
* 从本地bundle中加载 <code>imageNamed:</code>，传入一个bundle的文件名即可
* 从本地一个文件路径读取 <code>imageWithContentsOfFile:</code>，需要传一个文件的文件路径path
* 通过二进制数据<code>NSData</code>来创建<code>imageWithData:</code>
* 通过一个<code>CoreGraphics</code>的<code>CGImageRef</code>来创建，<code>initWithCGImage:</code>
* 通过一个<code>CoreImage</code>的<code>CIImage</code>来创建<code>initWithCIImage</code></p>

<p>通过查阅Apple官网文档我们发现有2个这样的方法，今天就来一探究竟</p>

<pre><code class="objective-c">+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);
+ (UIImage *)imageWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);

- (instancetype)initWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);
- (instancetype)initWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>2个类方法2个实例方法都是类似，这里以<code>CGImageRef</code>为例</p>

<pre><code class="objective-c">+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);
</code></pre>

<ol>
<li>新建的Xcode工程选择single Application</li>
<li>在storyboard中拖一个<code>UIImageView</code>设置它水平垂直居中对齐，宽带高度随便设一个值不要太大就行，设置<code>UIImageView</code>的<code>contentMode</code>为<code>Aspect Fit</code>方便查看以免变形</li>
<li>在<code>UIImageView</code>下发放一个<code>UIButton</code>控件方便后面好对图片进行旋转操作</li>
<li><p>在viewController中建立一个<code>UIImageView</code>引用,拉出一个rotate按钮的<code>IBAction</code></p>

<p> 现在大概界面大概这样
 <img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezhnagzyhpj20x7105doj.jpg" alt="UIImageOrientation效果图" /></p></li>
<li><p>下面我们实现
<code>- (IBAction)rotateImage:(id)sender {}</code>这个方法</p>

<blockquote><p>在这里我们想通过点击按钮实现图片旋转
  为了方便使用我们使用Category的方式实现
  新建一个UIImage的分类取名叫Rotate</p>

<p>这里需要传一张要处理的图片和一个待处理成的图片方向</p>

<pre><code class="``objective-c">  + (UIImage *)rotateImage:(UIImage *)oldImage
           orientation:(UIImageOrientation)orientation;
</code></pre></blockquote>

<pre><code class="``objective-c">  + (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation{

  UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation];

  NSString *orientationStr = nil;
  switch (orientation) {
      case UIImageOrientationUp: {
          orientationStr = @"UIImageOrientationUp";
          break;
      }
      case UIImageOrientationDown: {
          orientationStr = @"UIImageOrientationDown";
          break;
      }
      case UIImageOrientationLeft: {
          orientationStr = @"UIImageOrientationLeft";
          break;
      }
      case UIImageOrientationRight: {
          orientationStr = @"UIImageOrientationRight";
          break;
      }
      case UIImageOrientationUpMirrored: {
          orientationStr = @"UIImageOrientationUpMirrored";
          break;
      }
      case UIImageOrientationDownMirrored: {
          orientationStr = @"UIImageOrientationDownMirrored";
          break;
      }
      case UIImageOrientationLeftMirrored: {
          orientationStr = @"UIImageOrientationLeftMirrored";
          break;
      }
      case UIImageOrientationRightMirrored: {
          orientationStr = @"UIImageOrientationRightMirrored";
          break;
      }

  }

  NSLog(@"current orientation: %@",orientationStr);

  return newImage;
}
</code></pre></li>
</ol>


<p>在button点击事件触发时的这样使用</p>

<pre><code class="objective-c">- (IBAction)rotateImage:(id)sender {

    UIImage *oldImage = self.imgView.image;

    UIImage *rotatedImage = [UIImage rotateImage:oldImage orientation:UIImageOrientationLeft];

    self.imgView.image = rotatedImage;
}
</code></pre>

<p>点击按钮测试发现第一次没问题，但是重逢点击无效
原来<code>+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation</code>方法执行原理是执行前通过
<code>@property(nonatomic,readonly) UIImageOrientation imageOrientation;</code>接口先判断当前图片的方向是否为将要旋转的方向，
如果是就直接返回不做处理，如果不是再作旋转处理，
也就是说这个方法并没有实际上旋转image的数据，只是用一个枚举标记旋转的状态</p>

<p>如果我们想每次旋转需要直接改变原始image的数据该怎么办呢？
在这里我们通过<code>CGBitmapContext</code>,使用<code>CGContextRotateCTM</code>来设置旋转，
再把UIImage通过<code>drawInRect
</code>重新绘制出来，通过<code>UIGraphicsGetImageFromCurrentImageContext</code>获得处理后的图片
下面是具体实现</p>

<pre><code class="objective-c">- (UIImage *)fixedRotation{
    if (self.imageOrientation == UIImageOrientationUp) return self;
    CGAffineTransform transform = CGAffineTransformIdentity;

    switch (self.imageOrientation) {
        case UIImageOrientationDown:
        case UIImageOrientationDownMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height);
            transform = CGAffineTransformRotate(transform, M_PI);
            break;

        case UIImageOrientationLeft:
        case UIImageOrientationLeftMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.width, 0);
            transform = CGAffineTransformRotate(transform, M_PI_2);
            break;

        case UIImageOrientationRight:
        case UIImageOrientationRightMirrored:
            transform = CGAffineTransformTranslate(transform, 0, self.size.height);
            transform = CGAffineTransformRotate(transform, -M_PI_2);
            break;
        case UIImageOrientationUp:
        case UIImageOrientationUpMirrored:
            break;
    }

    switch (self.imageOrientation) {
        case UIImageOrientationUpMirrored:
        case UIImageOrientationDownMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.width, 0);
            transform = CGAffineTransformScale(transform, -1, 1);
            break;

        case UIImageOrientationLeftMirrored:
        case UIImageOrientationRightMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.height, 0);
            transform = CGAffineTransformScale(transform, -1, 1);
            break;
        case UIImageOrientationUp:
        case UIImageOrientationDown:
        case UIImageOrientationLeft:
        case UIImageOrientationRight:
            break;
    }

    // Now we draw the underlying CGImage into a new context, applying the transform
    // calculated above.
    CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height,
                                             CGImageGetBitsPerComponent(self.CGImage), 0,
                                             CGImageGetColorSpace(self.CGImage),
                                             CGImageGetBitmapInfo(self.CGImage));
    CGContextConcatCTM(ctx, transform);
    switch (self.imageOrientation) {
        case UIImageOrientationLeft:
        case UIImageOrientationLeftMirrored:
        case UIImageOrientationRight:
        case UIImageOrientationRightMirrored:
            // Grr...
            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);
            break;

        default:
            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);
            break;
    }

    // And now we just create a new UIImage from the drawing context
    CGImageRef cgimg = CGBitmapContextCreateImage(ctx);
    UIImage *img = [UIImage imageWithCGImage:cgimg];
    CGContextRelease(ctx);
    CGImageRelease(cgimg);
    return img;

}
</code></pre>

<p>现在再优化一下原来<code>+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation</code> 方法,修改成这样
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">UIImage</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">rotateImage:</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">oldImage</span> <span class="nf">orientation:</span><span class="p">(</span><span class="n">UIImageOrientation</span><span class="p">)</span><span class="nv">orientation</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">newImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">oldImage</span><span class="p">.</span><span class="bp">CGImage</span> <span class="nl">scale</span><span class="p">:</span><span class="mi">1</span> <span class="nl">orientation</span><span class="p">:</span><span class="n">orientation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//fix original Image with gived orientation.</span>
</span><span class='line'><span class="bp">UIImage</span> <span class="o">*</span><span class="n">fixedRotationImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">newImage</span> <span class="n">fixedRotation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">orientationStr</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">orientation</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationUp</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationUp&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationDown</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationDown&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationLeft</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationLeft&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationRight</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationRight&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationUpMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationUpMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationDownMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationDownMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationLeftMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationLeftMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationRightMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationRightMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;current orientation: %@&quot;</span><span class="p">,</span><span class="n">orientationStr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">fixedRotationImage</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
 现在再测试一下，well，It‘s OK。</p>

<p> have fun!!!</p>

<p>参考资料：
* <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#//apple_ref/c/tdef/UIImageOrientation">Apple-UIImage Class Reference</a>
* <a href="http://stackoverflow.com/questions/8915630/ios-uiimageview-how-to-handle-uiimage-image-orientation">ios-uiimageview-how-to-handle-uiimage-image-orientation</a>
* <a href="http://www.galloway.me.uk/2012/01/uiimageorientation-exif-orientation-sample-images/">UIImageOrientation / EXIF orientation sample images</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动画绘制CAShapeLayer的路径CGPath]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/"/>
    <updated>2016-01-13T04:35:42+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath</id>
    <content type="html"><![CDATA[<h1>Animating the Drawing of a CGPath With CAShapeLayer</h1>

<ul>
<li><a href="http://oleb.net/blog/2010/12/animating-drawing-of-cgpath-with-cashapelayer/">原文链接</a></li>
</ul>


<h1>这是什么？</h1>

<blockquote><p>此文将讲解通过形状图层<code>CAShaperLayer</code>的<code>strokeStart</code>和<code>strokeEnd</code>来实现动画绘制路径<code>CGPath</code>,此文是<a href="http://oleb.net">By Ole Begemann</a>创建于December 18, 2010,当时是发布iOS SDK 4.2时<code>CAShapeLayer</code>新增加的两个属性<a href="http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html#//apple_ref/doc/uid/TP40008314-CH1-SW16">strokeStart</a>和<a href="http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html#//apple_ref/doc/uid/TP40008314-CH1-SW15">strokeEnd</a>,这两个值是两个浮点数取值范围0.0~1.0,用来表明形状图层所指向的路径在绘制开始和结束路径中的相对位置。</p></blockquote>

<p><code>strokeStart</code>默认值是0.0，<code>strokeEnd</code>默认值是1.0，显然这会导致形状图层的路径将一整个被绘制。假如，你想说，如果设置了layer.strokeEnd = 0.5f,只让她绘制前半部分，那该多好。</p>

<p>真正有趣的事情是这些接口都是可动画的。通过动画绘制<code>strokeEnd</code>从0.0到1.0在几秒内，我们就能很容易自己绘制路径像下面这样写：</p>

<pre><code class="objective-c">CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
pathAnimation.duration = 10.0;
pathAnimation.fromValue = [NSNumber numberWithFloat:0.0f];
pathAnimation.toValue = [NSNumber numberWithFloat:1.0f];
[self.pathLayer addAnimation:pathAnimation forKey:@"strokeEndAnimation"];
</code></pre>

<p>最后，再添加第二个图层包含一个铅笔图片，使用关键帧动画<code>CAKeyframeAnimation</code>来让它随着这个路径以相同的速度绘制，就可以达到完美的错觉效果：</p>

<pre><code class="objective-c">CAKeyframeAnimation *penAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
penAnimation.duration = 10.0;
penAnimation.path = self.pathLayer.path;
penAnimation.calculationMode = kCAAnimationPaced;
[self.penLayer addAnimation:penAnimation forKey:@"penAnimation"];
</code></pre>

<p><a href="http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4">绘制普通路径效果视频</a></p>

<p><a href="http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4">下载地址</a></p>

<p>这个对文本一样有效；我们只需要把字符转化成<code>CGPath</code>。<code>Core Text</code>提供了那样的功能的函数，<a href="http://developer.apple.com/library/ios/documentation/Carbon/Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreatePathForGlyph">CTFontCreatePathForGlyph( )</a>。为了使用它，我们需要创建一个带属性的字符串用我们想要渲染的文本，先把它们分割成行在分割成一个个字符。在把所有的字符转换成路径后，我们以子路径方式把它添加到一个单个的<code>CGPath</code>路径中。更多细节可以查看<a href="http://www.codeproject.com/script/Membership/View.aspx?mid=2887692">Ohmu</a>写的<a href="http://www.codeproject.com/KB/iPhone/Glyph.aspx">Low-level text rendering</a>这篇文章。结果看以来非常的炫酷：</p>

<p><a href="http://oleb.net/media/AnimatedPathsHelloWorld.mp4">绘制文字路径效果视频</a></p>

<p><a href="http://oleb.net/media/AnimatedPathsHelloWorld.mp4">下载地址</a></p>

<p>从Github上获得<a href="http://github.com/ole/Animated-Paths">iPad版的样品工程</a></p>

<h1>你将学到的知识点</h1>

<ul>
<li>使用<code>CAShapeLayer</code>的<code>strokeStart</code>和<code>strokeEnd</code>来实现路径动画,比较高级复杂的效果像google的下拉刷新转圈就可以从这里引申去实现。</li>
<li><code>CABasicAnimation</code>和<code>CABasicAnimation</code>使用</li>
<li>深入理解<code>CAShapeLayer</code>和<code>CALayer</code></li>
<li>通过文本创建路径，核心函数<code>CTFontCreatePathForGlyph()</code></li>
</ul>


<h1>补充说明</h1>

<pre><code class="objective-c">    CAShapeLayer *pathLayer = [CAShapeLayer layer];
    pathLayer.frame = self.animationLayer.bounds;
    pathLayer.bounds = pathRect;
    pathLayer.geometryFlipped = YES;
    pathLayer.path = path.CGPath;
    pathLayer.strokeColor = [[UIColor blackColor] CGColor];
    pathLayer.fillColor = nil;
    pathLayer.lineWidth = 10.0f;
    pathLayer.lineJoin = kCALineJoinBevel;

    [self.animationLayer addSublayer:pathLayer];
</code></pre>

<p>有一点非常重要，CALayer在iOS系统中相对坐标系是以屏幕左上<code>top-left</code>为坐标原点的，在Mac OS X上以坐下<code>bottom-left</code>为坐标原点,但是可以通过<code>CALayer</code>的接口<code>geometryFlipped</code>垂直翻转坐标系，这个值默认是<code>NO</code>，设置成<code>YES</code>就可以把坐标系转换成左下<code>bottom-left</code>了，这里作者使用的左下<code>bottom-left</code>的坐标系。</p>

<pre><code class="objective-c">@property(getter=isGeometryFlipped) BOOL geometryFlipped;
</code></pre>

<p>关于这个属性使用时需要特别注意</p>

<ol>
<li>翻转会同时作用于它的子图层</li>
<li>即使这个属性设置成<code>YES</code>,图片的<code>orientation</code>仍然是不变的（也就是说当设置<code>flipped=YES</code>和<code>flipped=NO</code>时一个<code>CGImageRef</code>储存在<code>contents</code>接口中的内容将会显示一致，赋值并不会真正变换底层的图层）</li>
</ol>


<h3>pathLayer动画实现原理</h3>

<ol>
<li>先创建一个动画用的图层<code>animationLayer</code>类型<code>CALayer</code>，用来充当动画的画布。</li>
<li>创建真正的路径图层<code>pathLayer</code>类型为<code>CAShapeLayer</code>,让它的坐标系垂直翻转，并且让图层宽高同时向内收缩100个点,通过<code>CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)</code>实现</li>
<li>把<code>pathLayer</code>添加到<code>animationLayer</code>的子图层中去</li>
<li>创建一个铅笔图层<code>penLayer</code>类型为<code>CALayer</code>,把它添加到<code>pathLayer</code>去</li>
<li>对<code>pathLayer</code>添加<code>CABasicAnimation</code>动画，动画属性为<code>strokeEnd</code></li>
<li>对<code>penLayer</code>添加<code>CAKeyframeAnimation</code>动画，动画属性为<code>position</code></li>
</ol>


<h3>textLayer动画实现原理</h3>

<ol>
<li>先创建一个动画用的图层<code>animationLayer</code>类型<code>CALayer</code>，用来充当动画的画布</li>
<li>Create path from text,See:<a href="http://www.codeproject.com/KB/iPhone/Glyph.aspx">http://www.codeproject.com/KB/iPhone/Glyph.aspx</a>，最终保存到一个类型为<code>CGMutablePathRef</code>的letter中</li>
<li>通过letter来创建文字<code>UIBezierPath</code>类型的<code>path</code></li>
<li>通过path再创建<code>CAShapeLayer</code>pathLayer,并且把pathLayer添加到<code>animationLayer</code>中去</li>
<li>创建一个铅笔图层<code>penLayer</code>类型为<code>CALayer</code>,把它添加到<code>pathLayer</code>去</li>
<li>对<code>pathLayer</code>添加<code>CABasicAnimation</code>动画，动画属性为<code>strokeEnd</code></li>
<li>对<code>penLayer</code>添加<code>CAKeyframeAnimation</code>动画，动画属性为<code>position</code></li>
</ol>


<h3>修复一处bug</h3>

<p>重复点击<code>UISegmentedControl</code>导致铅笔消失，这是设置了<code>penAnimation.delegate = self;</code>在代理方法里面没有判断结束直接将设置<code>self.penLayer.hidden = YES</code>，导致连续切换时铅笔不见了，要修复这个bug只需加一个判断<code>   if (flag)   self.penLayer.hidden = YES;
</code>即可,这样的意思是只有当动画完成时才设置<code>self.penLayer.hidden</code>的值，好了现在已经非常完美了，快去动手自己试试吧！🍺</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的触摸事件和手势处理]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/"/>
    <updated>2016-01-13T04:34:00+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li</id>
    <content type="html"><![CDATA[<h3>iOS触摸事件分类</h3>

<ul>
<li>触摸事件</li>
<li>加速事件</li>
<li>远程事件</li>
</ul>


<h3>谁能处理触摸事件?</h3>

<p><strong>响应者对象</strong></p>

<p>在iOS中不是任何对象都能处理事件,只有继承了UIResponder的对象才能接收并处理事件.我们称之为<strong>响应者对象</strong>.</p>

<p><code>UIApplication</code>,<code>UIViewController</code>,<code>UIView</code>都继承自<code>UIResponder</code>,因此它们都是响应者对象,都能够接收并处理事件.</p>

<h3>UIResponder</h3>

<p>UIResponder内部提供了方法来处理事件</p>

<ol>
<li><p>触摸事件</p>

<p> 一次完成的触摸过程,会经历3个状态;
 UIView的触摸事件处理</p>

<p> 1.一根或多根手指开始触摸view,系统会自动调用view下面的方法:</p>

<pre><code> - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸开始
</code></pre>

 2.一根或者多根手指在view上移动，系统会自动调用view下面的方法（随着手指的移动，会持续调用该方法）

<pre><code> - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸移动
</code></pre>

 3.一根或者多根手指离开view，系统会自动调用view下面的方法

<pre><code> - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸结束
</code></pre>

 4.触摸结束前，某个系统事件（例如电话呼入 ）会打断触摸过程，系统会自动调用view下面的方法

<pre><code> - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; //触摸取消(可能会经历)
</code></pre>

 4个触摸事件的处理方法中，都有 NSSet <em>touches 和 UIEvent </em>event 两个参数:

<ul>
<li>一次完整的触摸过程，只会产生一个事件对象，4个触摸方法都是同一个event参数</li>
<li>如果两根手指同时触摸一个view，那么view只会调用一次 touchesBegan:withEvent: 方法，touches参数中装着两个UITouch对象；</li>
<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的touches参数只包含一个UITouch对象；</li>
<li>根据touches中UITouch个数可以判断出使单点触摸还是多点触摸</li>
</ul>


<p> 提示：touches中存放的都是UITouch对象。</p></li>
<li><p>加速计事件</p>

<pre><code> - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;
 - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;
 - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;
</code></pre></li>
<li><p>远程控制事件</p>

<pre><code> - (void)remoteControlReceivedWithEvent:(UIEvent *)event;
</code></pre></li>
</ol>


<h3>UITouch</h3>

<p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象；一根手指对应一个UITouch对象
UITouch的作用:</p>

<ul>
<li>保存跟手指相关的信息，比如触摸的位置、时间、阶段；</li>
<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置；</li>
<li>当手指离开屏幕时，系统会销毁相应的UITouch对象。</li>
</ul>


<p>提示：iPhone开发中，要避免使用双击事件。</p>

<p>UITouch的属性:
触摸产生时所处的窗口:</p>

<pre><code>@property(nonatomic,readonly,retain) UIWindow *window;
</code></pre>

<p>触摸产生时所处的视图</p>

<pre><code> @property(nonatomic,readonly,retain) UIView *view;
</code></pre>

<p>短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多地点击</p>

<pre><code> @property(nonatomic,readonly) NSUInteger tapCount;
</code></pre>

<p>记录了触摸事件产生或变化时的时间，单位是秒</p>

<pre><code> @property(nonatomic,readonly) NSTimeInterval timestamp;
</code></pre>

<p>当前触摸事件所处的状态</p>

<pre><code>@property(nonatomic,readonly) UITouchPhase phase;
/*
UITouchPhase是一个枚举类型，包含：
UITouchPhaseBegan（触摸开始）
UITouchPhaseMoved（接触点移动）
UITouchPhaseStationary（接触点无移动）
UITouchPhaseEnded（触摸结束）
UITouchPhaseCancelled（触摸取消）*/
</code></pre>

<p>UITouch的方法：</p>

<pre><code>- (CGPoint)locationInView:(UIView *)view;
</code></pre>

<p>1.返回值表示触摸在view上的位置；</p>

<p>2.这里返回的位置是针对view坐标系的,（以view的左上角为原点（0，0））；</p>

<p>3.调用时传入的view参数为nil 的话，返回的是触摸点在UIWindow的位置。</p>

<pre><code>- (CGPoint)previousLocationInView:(UIView *)view;
</code></pre>

<p>该方法记录了前一个触摸点的位置；</p>

<h3>UIEvent</h3>

<blockquote><p>每产生一个事件，就会产生一个UIEvent对象；</p>

<p>UIEvent:称为事件对象，记录事件产生的时刻和类型。</p></blockquote>

<p>常见属性：
1.事件类型</p>

<pre><code class="objective-c">@property(nonatomic,readonly) UIEventType  type;
@property(nonatomic,readonly) UIEventSubtype  subtype;

typedef
NS_ENUM(NSInteger, UIEventType) {
    UIEventTypeTouches,
    UIEventTypeMotion,
    UIEventTypeRemoteControl,
};
typedef
NS_ENUM(NSInteger, UIEventSubtype) {
    // available in iPhone OS 3.0
    UIEventSubtypeNone                              = 0,    
    // for UIEventTypeMotion, available in iPhone OS 3.0
    UIEventSubtypeMotionShake                       = 1,
    // for UIEventTypeRemoteControl, available in iOS 4.0
    UIEventSubtypeRemoteControlPlay                 = 100,
    UIEventSubtypeRemoteControlPause                = 101,
    UIEventSubtypeRemoteControlStop                 = 102,
    UIEventSubtypeRemoteControlTogglePlayPause      = 103,
    UIEventSubtypeRemoteControlNextTrack            = 104,  
    UIEventSubtypeRemoteControlPreviousTrack        = 105,
    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,   
    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,  
    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,  
    UIEventSubtypeRemoteControlEndSeekingForward    = 109,
};
</code></pre>

<p>2.事件产生的时间</p>

<pre><code>@property(nonatomic,readonly) NSTimeInterval  timestamp;
</code></pre>

<p> UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch）。</p>

<p> 触摸事件的产生：</p>

<ol>
<li><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中；</p></li>
<li><p>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）；</p></li>
<li><p>主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步；</p></li>
<li><p>找到合适的视图控件后，就会调用视图控件的touches方法来做具体的事件处理。</p></li>
</ol>


<p>触摸事件的传递：</p>

<blockquote><p>触摸事件的传递是从父控件传递到子控件；</p>

<p>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。</p></blockquote>

<p><img src="http://ww4.sinaimg.cn/mw690/64124373gw1eznrp087anj205t07rdfx.jpg" alt="触摸事件" />
<img src="http://ww2.sinaimg.cn/mw690/64124373gw1eznrrf36ymj2097077dhc.jpg" alt="触摸事件2" /></p>

<p>UIView不接收触摸事件的三种情况:
不接受用户交互 ：</p>

<ol>
<li><p>userInteractionEnable = NO;</p></li>
<li><p>隐藏 ：hidden = YES;</p></li>
<li><p>透明：alpha = 0.0 ~ 0.01</p></li>
</ol>


<p>提示：UIImageView的userInteractionEnable默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。</p>

<p>触摸事件处理的详细过程：</p>

<ol>
<li><p>用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件</p></li>
<li><p>找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理</p>

<p> touchesBegan…</p>

<p> touchesMoved…</p>

<p> touchedEnded…</p></li>
</ol>


<p>这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理</p>

<p>响应者链的事件传递过程：</p>

<ol>
<li><p>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图；</p></li>
<li><p>在视图层次结构最顶级的视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。</p></li>
<li><p>如果window对象也不处理，则其将事件或消息传递给UIApplication对象；</p></li>
<li><p>如果UIApplication也不能处理该事件或消息，则将其丢弃</p></li>
</ol>


<h3>监听触摸事件的做法</h3>

<p>如果想监听一个view上面的触摸事件，之前的做法是：</p>

<ol>
<li><p>自定义一个view；</p></li>
<li><p>实现view的touches方法，在方法内部实现具体处理代码。</p>

<p> 通过touches方法监听view触摸事件，有很明显的几个缺点：</p>

<ul>
<li><p>必须得自定义view；</p></li>
<li><p>由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件；</p></li>
<li><p>不容易区分用户的具体手势行为。</p></li>
</ul>
</li>
</ol>


<p>iOS 3.2之后，苹果推出了手势识别功能（Gesture Recognizer）,在触摸事件处理方面，大大简化了开发者的开发难度。</p>

<h3>UIGestureRescognizer</h3>

<p>为了完成手势识别，必须借助于手势识别器：UIGestureRecognizer 。</p>

<p>利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势。</p>

<p>UIGestureRecognizer是一个抽象类，定义了所有的手势基本行为，使用它的子类才能处理具体的手势</p>

<ul>
<li>UITapGestureRecognizer(敲击)</li>
<li>UIPinchGestureRecognizer(捏合，用于缩放)</li>
<li>UIPanGestureRecognizer(拖拽)</li>
<li>UISwipeGestureRecognizer(轻扫)</li>
<li>UIRotationGestureRecognizer(旋转)</li>
<li>UILongPressGestureRecognizer(长按)</li>
</ul>


<p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下:</p>

<ol>
<li><p>创建手势识别器对象；</p>

<p> UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</p></li>
<li><p>设置手势识别器对象的具体属性；</p>

<pre><code> // 连续敲击2次
 tap.numberOfTapsRequired = 2;
 // 需要2根手指一起敲击
 tap.numberOfTouchesRequired = 2;
</code></pre></li>
<li><p>添加手势识别器到对应的view上</p>

<p> [self.iconView addGestureRecognizer:tap];</p></li>
<li><p>监听手势的触发</p>

<p> [tap addTarget:self action:@selector(tapIconView:)];</p></li>
</ol>


<p>手势识别的状态</p>

<pre><code class="objective-c">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {
    // 没有触摸事件发生，所有手势识别的默认状态
    UIGestureRecognizerStatePossible,
    // 一个手势已经开始但尚未改变或者完成时
    UIGestureRecognizerStateBegan,
    // 手势状态改变
    UIGestureRecognizerStateChanged,
    // 手势完成
    UIGestureRecognizerStateEnded,
    // 手势取消，恢复至Possible状态
    UIGestureRecognizerStateCancelled,
    // 手势失败，恢复至Possible状态
    UIGestureRecognizerStateFailed,
    // 识别到手势识别
    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded
};
</code></pre>

<p>参考资料：<a href="http://my.oschina.net/aofe/blog/268749">傲风凌寒的博客</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[__autoreleasing的理解]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/autoreleasingde-li-jie/"/>
    <updated>2016-01-13T04:27:10+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/autoreleasingde-li-jie</id>
    <content type="html"><![CDATA[<h3>__autoreleasing 修饰符</h3>

<p>将对象赋值给附有__autoreleasing 修饰符的变量等同于ARC 无效时调用对象的autorelease方法。我们通过以下源代码来看一下</p>

<pre><code class="objective-c">@autoreleasepool {
id __autoreleasing obj  = [[NSObject alloc] init];
}
</code></pre>

<p>该源代码主要将NSObject 类对象注册到autoreleasepool 中，可作如下变换：</p>

<pre><code class="objective-c">/* 编译器的模拟代码 */
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);
</code></pre>

<p>这与苹果的autorelease 实现中的说明（参考1.2.7 节）完全相同。虽然ARC 有效和无效时，其在源代码上的表现有所不同，但autorelease 的功能完全一样。</p>

<p>在alloc/new/copy/mutableCopy 方法群之外的方法中使用注册到autoreleasepool 中的对象会如何呢？下面我们来看看NSMutableArray 类的array 类方法。</p>

<pre><code class="objective-c">@autoreleasepool {
id __autoreleasing obj = [NSMutableArray array];
}
</code></pre>

<p>这与前面的源代码有何不同呢？</p>

<pre><code class="objective-c">/* 编译器的模拟代码 */
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSMutableArray, @selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);
</code></pre>

<p>虽然持有对象的方法从alloc 方法变为objc_retainAutoreleasedReturnValue 函数， 但注册autoreleasepool 的方法没有改变，仍是objc_autorelease 函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[__attribute__]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/attribute/"/>
    <updated>2016-01-13T04:10:33+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/attribute</id>
    <content type="html"><![CDATA[<ul>
<li>译自 Written by <a href="http://nshipster.com/authors/mattt-thompson/">Mattt Thompson</a> — January 14th, 2013</li>
<li>原文链接：<a href="http://nshipster.com/__attribute__/">http://nshipster.com/__attribute__/</a></li>
<li>译者<a href="https://twitter.com/oneruofeng">@oneruofeng</a></li>
</ul>


<p>重复发布这个主题已经说明了同编译器保存健康关系的重要性,像任何草稿一样，作为一个实践者的效率取决于他们怎样对待他们的工具，你照顾好它们，它们反过来也会对你有好处。</p>

<p> <code>__attribute__</code>是一个编译器的指令在声明的时候指明了一些参数，这些参数允许更多的检查错误和高级的优化。</p>

<p> 语法关键字是<code>__attribute__</code>紧跟2套圆括号（双圆括号让出现的宏更容易辨认，特别是在有多个属性的时候）。在括号内部是一个以逗号分隔的属性列表，<code>__attribute__</code>指令被放在函数，变量和类型声明后面。</p>

<pre><code class="objective-c"> // Return the square of a number
int square(int n) __attribute__((const));

// Declare the availability of a particular API
void f(void)
  __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));

// Send printf-like message to stderr and exit
extern void die(const char *format, ...)
  __attribute__((noreturn, format(printf, 1, 2)));
</code></pre>

<p>假如这个让你想起ISO C语言的 <code>#pragma</code>,你就不会感到孤单了。</p>

<p>实际上，当<code>__attribute__</code>被第一次引入到<code>GCC</code>编译器时，它面临一些阻力，有人建议使用专用的<code>#pragma</code>因为相同的目的。</p>

<p>这里，然而，有2个非常好的理由为什么<code>__attribute__</code>被添加进来</p>

<blockquote><ul>
<li>从一个宏中产生<code>#pragma</code>命令几乎是不能的（在C99 _Pragma 预算符以前）。</li>
<li>这里没人知道相同的<code>#pragma</code>在另一个编译器中可能的意思。</li>
</ul>
</blockquote>

<p> 引用<a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">GCC Documentation for Function Attributes</a></p>

<blockquote><ul>
<li>这里有2个原因被应用到几乎所有的应用推荐使用<code>#pragma</code>,这犯了一个低级错误就是把<code>#pragma</code>使用到任何地方。</li>
</ul>
</blockquote>

<p> 确实，假如你在苹果的框架中和牛逼工程师的开源项目中的头文件看一下现代的<code>Objective-c</code>&ndash;<code>__attribute__</code>被大量使用。（相反，<code>#pragma</code>的主要声明名声来着这些天是装饰:<code>#pragma mark</code>）</p>

<p> 所以为了以后不费力，我们还是先看一下最重要的属性：</p>

<hr />

<h2>GCC</h2>

<p><strong>format</strong></p>

<blockquote><p><code>format</code>属性指定了一个函数像<code>printf</code>,<code>scanf</code>,<code>strftime</code>或者<code>strfmo</code>风格的参数，这个参数应该是可以进行类型检查的一个格式化字符串。</p></blockquote>

<pre><code class="objective-c">extern int
my_printf (void *my_object, const char *my_format, ...)
  __attribute__((format(printf, 2, 3)));
</code></pre>

<p>Objective-C程序员也可使用<code>__NSString__</code>来格式化来做到相同的格式化规则，像在<code>NNString</code>中通过 <code>+stringWithFormat:</code> 和 <code>NSLog()</code>格式化字符串一样。</p>

<p><strong>nonnull</strong></p>

<blockquote><p>这个<code>nonnull</code>属性指定了某些函数的参数必须是非空的指针。</p></blockquote>

<pre><code class="objective-c">extern void *
my_memcpy (void *dest, const void *src, size_t len)
  __attribute__((nonnull (1, 2)));
</code></pre>

<p>使用<code>nonnull</code>编码期望这个值遵守一个明确的约定中，这样能帮助捕获潜伏在任何代码调用的NULL指针bugs，请记住：
<code>编译时的错误 &gt;&gt;  运行时的错误。</code></p>

<p><strong>noreturn</strong></p>

<blockquote><p>一些标准库函数，例如<code>abort</code>和<code>exit</code>,是不能返回的。GCC自动知道这些东西，这个noreturn属性用于指定任何其他函数永远不会返回的情况。</p></blockquote>

<p>例如，AFNetworking 使用<code>noreturn</code>属性在它的<a href="https://github.com/AFNetworking/AFNetworking/blob/1.1.0/AFNetworking/AFURLConnectionOperation.m#L157">网络请求线程进入点的方法</a>里面,这个方法用在当大量产生专用的网络的线程里用来保证分离的线程持续执行在应用的整个生命周期中。</p>

<p><strong>pure/const</strong></p>

<blockquote><p><code>pure</code>属性指定了一个函数除了返回值没有副作用，例如它的返回值仅仅依赖参数和/或者全局变量。这样的函数可以用公共子表达式消除并且循环优化就像一个算数操作符那样。</p>

<p><code>pure</code>属性指定了一个函数不会检查任何值除了它们的参数，并且返回值没有副作用。注意到一个函数有一个指针参数并且需呀检查数据的指向不能声明成<code>const</code>。同样的，一个函数调用一个非<code>nonst</code>函数通常不能为<code>const</code>,一个<code>const</code>函数返回<code>void</code>并没有什么意义。</p></blockquote>

<pre><code class="objective-c">int square(int n) __attribute__((const));
</code></pre>

<p><code>pure</code>和<code>const</code>是两个执行在一个函数式编程惯例中的参数为了允许有效性能优化。<code>const</code>可以被认为是严格形式的<code>pure</code>因为它不依赖全局变量或者指针。</p>

<p>例如，因为一个函数声明为<code>const</code>的结果并不依赖任何东西除了传进来的参数。函数的结果能够缓存那个结果并且当函数被调用时返回，这样的函数叫做相同的组合参数（也就是说，我们知道一个数字的平方是一个常量，所以我们仅仅需要只计算它一次)。</p>

<p><strong>unused</strong></p>

<blockquote><p>这个属性，附着在一个函数后面，意味着那个函数很可能不会被使用，GCC不会对这个函数产生警告。</p></blockquote>

<p>用<code>__unused</code>关键词可以获得相同的效果，声明这个在方法实现中不会被使用的参数中。知道那以后一些上下文就可以允许编译器来做相应的优化。你很可能喜欢在delegate方法实现李勉使用<code>__unused</code>,因为协议频繁的提高更多的上下文比通常必要的情况，为了满足大量的潜在使用案例。</p>

<h3>LLVM</h3>

<p>像GCC的很多特征一样，Clang也支持<code>__attribute__</code>,添加到它自己的小范围的扩展。为了检查某个属性的可用性，你可以直接使用<code>__has_attribute</code>属性。</p>

<p><strong>availability</strong></p>

<blockquote><p>Clang引进了availability属性，这个可以被取代在声明描述的生命周期中声明相对于操作系统的版本。思考对一个简单函数f：的函数声明</p></blockquote>

<pre><code class="objective-c">void f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6,obsoleted=10.7)));
</code></pre>

<blockquote><p><code>availability</code>属性声明f在OS X老虎系统中被引入，在OS X雪豹系统中被弃用，在OS X 山狮系统中被废弃。</p>

<p>这个信息被Clang用来决定什么时候使用f：函数式安全的，例如，假如Clang在OS X 美洲豹系统上编译，调用f()函数将成功。假如Clang在OS X雪豹系统中编译，函数调用将成功但是Clang会发出一个警告指明这个函数被弃用了。最后，假如Clang被引进编译OS X山狮系统的代码，函数调用将失败，因为f()函数已经不再可用了。</p>

<p><code>availability</code>属性是一个逗号分隔的列表以平台名开始然后引入一些定语列举出生命周期内的重要里程碑事件附加额外的信息（以任何顺序）。</p></blockquote>

<ul>
<li>introduced：声明被引入的第一个版本</li>
<li>deprecated：声明被弃用的第一个版本，这意味着用户应该把这个API移走</li>
<li>obsoleted： 声明被废弃的第一个版本，这意味着它将被完全移除并且不能再使用</li>
<li>unavailable：声明在这个平台上将永远不可用</li>
<li>message：额外的消息将被Clang提供当忽略一个警告或者一个错误在使用一个被弃用或者被废弃的声明。对引导用户替换APIs很有用。</li>
</ul>


<blockquote><p>在声明时可以使用多个availability属性，每个对应不同的平台，仅当availability属性对应相应的目标平台被使用的时候，任何其他才将被忽略。假如没有availability 属性指定可用性对现在的目标平台，availability 属性将被忽略。</p></blockquote>

<h4>支持的平台：</h4>

<ul>
<li>ios：苹果的iOS操作系统。最小的部署目标被指定通过<code>-mios-version-min=*version*</code>或者<code>-miphoneos-version-min=*version*</code>命令行参数。</li>
<li>macosx：苹果的OS X 操作系统，最小的部署目标被指定通过<code>-mmacosx-version-min=*version*</code>命令行参数</li>
</ul>


<p><strong>overloadable</strong></p>

<blockquote><p>Clang提供对C++函数在C中重载的支持。在C中函数重载被引进使用<code>overloadable</code>属性。例如，一个可能提供一个重载版本的<code>tgsin</code>函数来精确执行相关的标准函数计算<code>float</code>,<code>double</code>,<code>long double</code>的正弦值：</p></blockquote>

<pre><code class="objective-c">#include &lt;math.h&gt;
float __attribute__((overloadable)) tgsin(float x) { return sinf(x); }
double __attribute__((overloadable)) tgsin(double x) { return sin(x); }
long double __attribute__((overloadable)) tgsin(long double x) { return sinl(x); }
</code></pre>

<p>请注意<code>overloadable</code>只对函数起作用。你可以重载方法声明在某种范围内通过使用通用的返回值和参数类型，想<code>id</code>或者<code>void *</code>.</p>

<hr />

<p>上下文是国王当它遇到编译器优化时。通过提供限制在怎样解析你的代码，增加你参数尽可能高效代码的可能性。遇到编译器把你打断，这将是一项奖励。</p>

<p>还有<code>__attribute__</code>并不仅仅对编译器有用：下一个人看代码也将感谢这些额外的上下文。所以多走几英尺远将对你的合作中和接替者或者从现在算2年以后的你(那个时候你已经忘记了所以的事情关于这份代码)自己有用</p>

<p>你付出了多少爱,最终你会得到多少爱。</p>
]]></content>
  </entry>
  
</feed>
