<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 王若风的小窝]]></title>
  <link href="http://wangruofeng.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wangruofeng.github.io/"/>
  <updated>2016-01-13T05:16:40+08:00</updated>
  <id>http://wangruofeng.github.io/</id>
  <author>
    <name><![CDATA[Ace]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多线程之NSOperation]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/duo-xian-cheng-zhi-nsoperation/"/>
    <updated>2016-01-13T05:14:59+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/duo-xian-cheng-zhi-nsoperation</id>
    <content type="html"><![CDATA[<h3>本文目录</h3>

<ul>
<li>前言</li>
<li>1.NSInvocationOperation</li>
<li>2.NSBlokcOperation</li>
<li>3.NSOperation的其他用法</li>
<li>4.自定义NSOperation</li>
</ul>


<h2>前言</h2>

<p>1.虽然<code>NSThread</code>也可以实现多线程编程，但是需要我们去管理线程的生命周期，还要考虑线程同步、加锁问题，造成一些性能上的开销。我们也可以配合使用<code>NSOperation</code>和<code>NSOperationQueue</code>实现多线程编程，实现步骤大致是这样的</p>

<ul>
<li>先将需要执行的操作封装到一个NSOperation对象中</li>
<li>然后将NSOperation对象添加到NSOperationQueue中</li>
<li>系统会自动将<code>NSOperation</code>中封装的操作放到一条新线程中执行在此过程中，我们根本不用考虑线程的生命周期、同步、加锁等问题下面列举一个应用场景，比如微博的粉丝列表：</li>
</ul>


<p><img src="http://images.cnitblog.com/blog/497279/201304/19122046-b40c752b60a5413290b569f5377ef7f3.png" alt="微博的粉丝列表" /></p>

<p>每一行的头像肯定要从新浪服务器下载图片后才能显示的，而且是需要异步下载。这时候你就可以把每一行的图片下载操作封装到一个<code>NSOperation</code>对象中，上面有6行，所以要创建6个<code>NSOperation</code>对象，然后添加到<code>NSOperationQueue</code>中，分别下载不同的图片，下载完毕后，回到对应的行将图片显示出来。</p>

<p>2 .默认情况下，<code>NSOperation</code>并不具备封装操作的能力，必须使用它的子类，使用NSOperation子类的方式有3种：</p>

<ul>
<li>NSInvocationOperation</li>
<li>NSBlockOperation</li>
<li>自定义子类继承NSOperation，实现内部相应的方法</li>
</ul>


<p>这讲先介绍如何用<code>NSOperation</code>封装一个操作，后面再结合<code>NSOperationQueue</code>来使用。</p>

<h2>1.NSInvocationOperation</h2>

<pre><code class="objective-c">NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run:) object:@"mj"];
[operation start];
</code></pre>

<ul>
<li>第1行初始化了一个<code>NSInvocationOperation</code>对象，它是基于一个对象和selector来创建操作</li>
<li>第2行调用了start方法，紧接着会马上执行封装好的操作，也就是会调用self的run:方法，并且将@&ldquo;mj"作为方法参数</li>
<li>这里要注意：默认情况下，调用了start方法后并不会开一条新线程去执行操作，而是在当前线程同步执行操作。只有将operation放到一个NSOperationQueue中，才会异步执行操作。</li>
</ul>


<h2>2.NSBlockOperation</h2>

<h3>a.同步执行一个操作</h3>

<pre><code class="objective-c">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){
         NSLog(@"执行了一个新的操作");
 }];
  // 开始执行任务
[operation start];
</code></pre>

<ul>
<li>第1行初始化了一个NSBlockOperation对象，它是用一个Block来封装需要执行的操作</li>
<li>第2行调用了start方法，紧接着会马上执行Block中的内容</li>
<li>这里还是在当前线程同步执行操作，并没有异步执行</li>
</ul>


<h3>b.并发执行多个操作</h3>

<pre><code class="objective-c">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^(){
　　NSLog(@"执行第1次操作，线程：%@", [NSThread currentThread]);
}];

[operation addExecutionBlock:^() {
　　NSLog(@"又执行了1个新的操作，线程：%@", [NSThread currentThread]);
}];

[operation addExecutionBlock:^() {
　　NSLog(@"又执行了1个新的操作，线程：%@", [NSThread currentThread]);
}];

[operation addExecutionBlock:^() {
　　NSLog(@"又执行了1个新的操作，线程：%@", [NSThread currentThread]);
}];

// 开始执行任务
[operation start];
</code></pre>

<ul>
<li>第1行初始化了一个NSBlockOperation对象</li>
<li>分别在第5、9、13行通过addExecutionBlock:方法添加了新的操作，包括第1行的操作，一共封装了4个操作</li>
<li><p>在第18行调用start方法后，就会并发地执行这4个操作，也就是会在不同线程中执行</p>

<pre><code>  1 2013-02-02 21:38:46.102 thread[4602:c07] 又执行了1个新的操作，线程：&lt;NSThread: 0x7121d50&gt;{name = (null), num = 1}
  2 2013-02-02 21:38:46.102 thread[4602:3f03] 又执行了1个新的操作，线程：&lt;NSThread: 0x742e1d0&gt;{name = (null), num = 5}
  3 2013-02-02 21:38:46.102 thread[4602:1b03] 执行第1次操作，线程：&lt;NSThread: 0x742de50&gt;{name = (null), num = 3}
  4 2013-02-02 21:38:46.102 thread[4602:1303] 又执行了1个新的操作，线程：&lt;NSThread: 0x7157bf0&gt;{name = (null), num = 4}
</code></pre></li>
</ul>


<p>可以看出，每个操作所在线程的num值都不一样，说明是不同线程</p>

<h2>3.NSOperation的其他用法</h2>

<h3>a.取消操作</h3>

<p>operation开始执行之后, 默认会一直执行操作直到完成，我们也可以调用cancel方法中途取消操作</p>

<pre><code>[operation cancel];
</code></pre>

<h3>b.在操作完成后做一些事情</h3>

<p>如果想在一个NSOperation执行完毕后做一些事情，就调用NSOperation的setCompletionBlock方法来设置想做的事情</p>

<pre><code>operation.completionBlock = ^() {
    NSLog(@"执行完毕");
};
</code></pre>

<p>当operation封装的操作执行完毕后，就会回调Block里面的内容</p>

<h2>4.自定义NSOperation</h2>

<p>如果<code>NSInvocationOperation</code>和<code>NSBlockOperation</code>不能满足需求，我们可以直接新建子类继承NSOperation，并添加任何需要执行的操作。如果只是简单地自定义NSOperation，只需要重载<code>-(void)main</code>这个方法，在这个方法里面添加需要执行的操作。</p>

<p>下面写个子类DownloadOperation来下载图片</p>

<h3>a.继承NSOperation，重写main方法</h3>

<p><em>DownloadOperation.h</em></p>

<pre><code class="objective-c">#import &lt;Foundation/Foundation.h&gt;
@protocol DownloadOperationDelegate;

@interface DownloadOperation : NSOperation
// 图片的url路径
@property (nonatomic, copy) NSString *imageUrl;
// 代理
@property (nonatomic, assign) id&lt;DownloadOperationDelegate&gt; delegate;

- (id)initWithUrl:(NSString *)url delegate:(id&lt;DownloadOperationDelegate&gt;)delegate;
@end

// 图片下载的协议
@protocol DownloadOperationDelegate &lt;NSObject&gt;
- (void)downloadFinishWithImage:(UIImage *)image;
@end
</code></pre>

<p>*DownloadOperation.m</p>

<pre><code class="objective-c">#import "DownloadOperation.h"

@implementation DownloadOperation
@synthesize delegate = _delegate;
@synthesize imageUrl = _imageUrl;

// 初始化
- (id)initWithUrl:(NSString *)url delegate:(id&lt;DownloadOperationDelegate&gt;)delegate {
    if (self = [super init]) {
        self.imageUrl = url;
        self.delegate = delegate;
    }
    return self;
}
// 释放内存
- (void)dealloc {
    [super dealloc];
    [_imageUrl release];
}

// 执行主任务
- (void)main {
    // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池
    @autoreleasepool {
        // ....
    }
}
@end
</code></pre>

<ul>
<li>在第22行重载了main方法，等会就把下载图片的代码写到这个方法中</li>
<li>如果这个DownloadOperation是在异步线程中执行操作，也就是说main方法在异步线程调用，那么将无法访问主线程的自动释放池，所以在第24行创建了一个属于当前线程的自动释放池</li>
</ul>


<h3>b.正确响应取消事件</h3>

<ul>
<li>默认情况下，一个NSOperation开始执行之后，会一直执行任务到结束，就比如上面的DownloadOperation，默认会执行完main方法中的所有代码</li>
<li>NSOperation提供了一个cancel方法，可以取消当前的操作。</li>
<li>如果是自定义NSOperation的话，需要手动处理这个取消事件。比如，一旦调用了cancel方法，应该马上终止main方法的执行，并及时回收一些资源。</li>
<li>处理取消事件的具体做法是：在<code>main</code>方法中定期地调用<code>isCancelled</code>方法检测操作是否已经被取消，也就是说是否调用了<code>cancel</code>方法，如果返回YES，表示已取消，则立即让main方法返回。</li>
<li>以下地方可能需要调用<code>isCancelled</code>方法:

<ol>
<li>在执行任何实际的工作之前，也就是在main方法的开头。因为取消可能发生在任何时候，甚至在operation执行之前。</li>
<li>执行了一段耗时的操作之后也需要检测操作是否已经被取消</li>
</ol>
</li>
</ul>


<pre><code class="objective-c">- (void)main {
    // 新建一个自动释放池，如果是异步执行操作，那么将无法访问到主线程的自动释放池
    @autoreleasepool {
        if (self.isCancelled) return;

        // 获取图片数据
        NSURL *url = [NSURL URLWithString:self.imageUrl];
        NSData *imageData = [NSData dataWithContentsOfURL:url];

        if (self.isCancelled) {
            url = nil;
            imageData = nil;
            return;
        }

        // 初始化图片
        UIImage *image = [UIImage imageWithData:imageData];

        if (self.isCancelled) {
            image = nil;
            return;
        }

        if ([self.delegate respondsToSelector:@selector(downloadFinishWithImage:)]) {
            // 把图片数据传回到主线程
            [(NSObject *)self.delegate performSelectorOnMainThread:@selector(downloadFinishWithImage:) withObject:image waitUntilDone:NO];
        }
    }
}
</code></pre>

<ul>
<li>在第4行main方法的开头就先判断operation有没有被取消。如果被取消了，那就没有必要往下执行了</li>
<li>经过第8行下载图片后，在第10行也需要判断操作有没有被取消</li>
<li>总之，执行了一段比较耗时的操作之后，都需要判断操作有没有被取消</li>
<li>图片下载完毕后，在第26行将图片数据传递给了代理(delegate)对象</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS中的触摸事件和手势处理]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/"/>
    <updated>2016-01-13T05:05:09+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li</id>
    <content type="html"><![CDATA[<h3>iOS触摸事件分类</h3>

<ul>
<li>触摸事件</li>
<li>加速事件</li>
<li>远程事件</li>
</ul>


<h3>谁能处理触摸事件?</h3>

<p><strong>响应者对象</strong></p>

<p>在iOS中不是任何对象都能处理事件,只有继承了UIResponder的对象才能接收并处理事件.我们称之为<strong>响应者对象</strong>.</p>

<p><code>UIApplication</code>,<code>UIViewController</code>,<code>UIView</code>都继承自<code>UIResponder</code>,因此它们都是响应者对象,都能够接收并处理事件.</p>

<h3>UIResponder</h3>

<p>UIResponder内部提供了方法来处理事件</p>

<ol>
<li><p>触摸事件</p>

<p> 一次完成的触摸过程,会经历3个状态;
 UIView的触摸事件处理</p>

<p> 1.一根或多根手指开始触摸view,系统会自动调用view下面的方法:</p>

<pre><code> - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸开始
</code></pre>

 2.一根或者多根手指在view上移动，系统会自动调用view下面的方法（随着手指的移动，会持续调用该方法）

<pre><code> - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸移动
</code></pre>

 3.一根或者多根手指离开view，系统会自动调用view下面的方法

<pre><code> - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸结束
</code></pre>

 4.触摸结束前，某个系统事件（例如电话呼入 ）会打断触摸过程，系统会自动调用view下面的方法

<pre><code> - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; //触摸取消(可能会经历)
</code></pre>

 4个触摸事件的处理方法中，都有 NSSet <em>touches 和 UIEvent </em>event 两个参数:

<ul>
<li>一次完整的触摸过程，只会产生一个事件对象，4个触摸方法都是同一个event参数</li>
<li>如果两根手指同时触摸一个view，那么view只会调用一次 touchesBegan:withEvent: 方法，touches参数中装着两个UITouch对象；</li>
<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的touches参数只包含一个UITouch对象；</li>
<li>根据touches中UITouch个数可以判断出使单点触摸还是多点触摸</li>
</ul>


<p> 提示：touches中存放的都是UITouch对象。</p></li>
<li><p>加速计事件</p>

<pre><code> - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;
 - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;
 - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;
</code></pre></li>
<li><p>远程控制事件</p>

<pre><code> - (void)remoteControlReceivedWithEvent:(UIEvent *)event;
</code></pre></li>
</ol>


<h3>UITouch</h3>

<p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象；一根手指对应一个UITouch对象
UITouch的作用:</p>

<ul>
<li>保存跟手指相关的信息，比如触摸的位置、时间、阶段；</li>
<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置；</li>
<li>当手指离开屏幕时，系统会销毁相应的UITouch对象。</li>
</ul>


<p>提示：iPhone开发中，要避免使用双击事件。</p>

<p>UITouch的属性:
触摸产生时所处的窗口:</p>

<pre><code>@property(nonatomic,readonly,retain) UIWindow *window;
</code></pre>

<p>触摸产生时所处的视图</p>

<pre><code> @property(nonatomic,readonly,retain) UIView *view;
</code></pre>

<p>短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多地点击</p>

<pre><code> @property(nonatomic,readonly) NSUInteger tapCount;
</code></pre>

<p>记录了触摸事件产生或变化时的时间，单位是秒</p>

<pre><code> @property(nonatomic,readonly) NSTimeInterval timestamp;
</code></pre>

<p>当前触摸事件所处的状态</p>

<pre><code>@property(nonatomic,readonly) UITouchPhase phase;
/*
UITouchPhase是一个枚举类型，包含：
UITouchPhaseBegan（触摸开始）
UITouchPhaseMoved（接触点移动）
UITouchPhaseStationary（接触点无移动）
UITouchPhaseEnded（触摸结束）
UITouchPhaseCancelled（触摸取消）*/
</code></pre>

<p>UITouch的方法：</p>

<pre><code>- (CGPoint)locationInView:(UIView *)view;
</code></pre>

<p>1.返回值表示触摸在view上的位置；</p>

<p>2.这里返回的位置是针对view坐标系的,（以view的左上角为原点（0，0））；</p>

<p>3.调用时传入的view参数为nil 的话，返回的是触摸点在UIWindow的位置。</p>

<pre><code>- (CGPoint)previousLocationInView:(UIView *)view;
</code></pre>

<p>该方法记录了前一个触摸点的位置；</p>

<h3>UIEvent</h3>

<blockquote><p>每产生一个事件，就会产生一个UIEvent对象；</p>

<p>UIEvent:称为事件对象，记录事件产生的时刻和类型。</p></blockquote>

<p>常见属性：
1.事件类型</p>

<pre><code class="objective-c">@property(nonatomic,readonly) UIEventType  type;
@property(nonatomic,readonly) UIEventSubtype  subtype;

typedef
NS_ENUM(NSInteger, UIEventType) {
    UIEventTypeTouches,
    UIEventTypeMotion,
    UIEventTypeRemoteControl,
};
typedef
NS_ENUM(NSInteger, UIEventSubtype) {
    // available in iPhone OS 3.0
    UIEventSubtypeNone                              = 0,    
    // for UIEventTypeMotion, available in iPhone OS 3.0
    UIEventSubtypeMotionShake                       = 1,
    // for UIEventTypeRemoteControl, available in iOS 4.0
    UIEventSubtypeRemoteControlPlay                 = 100,
    UIEventSubtypeRemoteControlPause                = 101,
    UIEventSubtypeRemoteControlStop                 = 102,
    UIEventSubtypeRemoteControlTogglePlayPause      = 103,
    UIEventSubtypeRemoteControlNextTrack            = 104,  
    UIEventSubtypeRemoteControlPreviousTrack        = 105,
    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,   
    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,  
    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,  
    UIEventSubtypeRemoteControlEndSeekingForward    = 109,
};
</code></pre>

<p>2.事件产生的时间</p>

<pre><code>@property(nonatomic,readonly) NSTimeInterval  timestamp;
</code></pre>

<p> UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch）。</p>

<p> 触摸事件的产生：</p>

<ol>
<li><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中；</p></li>
<li><p>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）；</p></li>
<li><p>主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步；</p></li>
<li><p>找到合适的视图控件后，就会调用视图控件的touches方法来做具体的事件处理。</p></li>
</ol>


<p>触摸事件的传递：</p>

<blockquote><p>触摸事件的传递是从父控件传递到子控件；</p>

<p>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。</p></blockquote>

<p><img src="http://ww4.sinaimg.cn/mw690/64124373gw1eznrp087anj205t07rdfx.jpg" alt="触摸事件" />
<img src="http://ww2.sinaimg.cn/mw690/64124373gw1eznrrf36ymj2097077dhc.jpg" alt="触摸事件2" /></p>

<p>UIView不接收触摸事件的三种情况:
不接受用户交互 ：</p>

<ol>
<li><p>userInteractionEnable = NO;</p></li>
<li><p>隐藏 ：hidden = YES;</p></li>
<li><p>透明：alpha = 0.0 ~ 0.01</p></li>
</ol>


<p>提示：UIImageView的userInteractionEnable默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。</p>

<p>触摸事件处理的详细过程：</p>

<ol>
<li><p>用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件</p></li>
<li><p>找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理</p>

<p> touchesBegan…</p>

<p> touchesMoved…</p>

<p> touchedEnded…</p></li>
</ol>


<p>这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理</p>

<p>响应者链的事件传递过程：</p>

<ol>
<li><p>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图；</p></li>
<li><p>在视图层次结构最顶级的视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。</p></li>
<li><p>如果window对象也不处理，则其将事件或消息传递给UIApplication对象；</p></li>
<li><p>如果UIApplication也不能处理该事件或消息，则将其丢弃</p></li>
</ol>


<h3>监听触摸事件的做法</h3>

<p>如果想监听一个view上面的触摸事件，之前的做法是：</p>

<ol>
<li><p>自定义一个view；</p></li>
<li><p>实现view的touches方法，在方法内部实现具体处理代码。</p>

<p> 通过touches方法监听view触摸事件，有很明显的几个缺点：</p>

<ul>
<li><p>必须得自定义view；</p></li>
<li><p>由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件；</p></li>
<li><p>不容易区分用户的具体手势行为。</p></li>
</ul>
</li>
</ol>


<p>iOS 3.2之后，苹果推出了手势识别功能（Gesture Recognizer）,在触摸事件处理方面，大大简化了开发者的开发难度。</p>

<h3>UIGestureRescognizer</h3>

<p>为了完成手势识别，必须借助于手势识别器：UIGestureRecognizer 。</p>

<p>利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势。</p>

<p>UIGestureRecognizer是一个抽象类，定义了所有的手势基本行为，使用它的子类才能处理具体的手势</p>

<ul>
<li>UITapGestureRecognizer(敲击)</li>
<li>UIPinchGestureRecognizer(捏合，用于缩放)</li>
<li>UIPanGestureRecognizer(拖拽)</li>
<li>UISwipeGestureRecognizer(轻扫)</li>
<li>UIRotationGestureRecognizer(旋转)</li>
<li>UILongPressGestureRecognizer(长按)</li>
</ul>


<p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下:</p>

<ol>
<li><p>创建手势识别器对象；</p>

<p> UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</p></li>
<li><p>设置手势识别器对象的具体属性；</p>

<pre><code> // 连续敲击2次
 tap.numberOfTapsRequired = 2;
 // 需要2根手指一起敲击
 tap.numberOfTouchesRequired = 2;
</code></pre></li>
<li><p>添加手势识别器到对应的view上</p>

<p> [self.iconView addGestureRecognizer:tap];</p></li>
<li><p>监听手势的触发</p>

<p> [tap addTarget:self action:@selector(tapIconView:)];</p></li>
</ol>


<p>手势识别的状态</p>

<pre><code class="objective-c">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {
    // 没有触摸事件发生，所有手势识别的默认状态
    UIGestureRecognizerStatePossible,
    // 一个手势已经开始但尚未改变或者完成时
    UIGestureRecognizerStateBegan,
    // 手势状态改变
    UIGestureRecognizerStateChanged,
    // 手势完成
    UIGestureRecognizerStateEnded,
    // 手势取消，恢复至Possible状态
    UIGestureRecognizerStateCancelled,
    // 手势失败，恢复至Possible状态
    UIGestureRecognizerStateFailed,
    // 识别到手势识别
    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded
};
</code></pre>

<p>参考资料：<a href="http://my.oschina.net/aofe/blog/268749">傲风凌寒的博客</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS里程碑事件]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/iosli-cheng-bei-shi-jian/"/>
    <updated>2016-01-13T04:46:48+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/iosli-cheng-bei-shi-jian</id>
    <content type="html"><![CDATA[<blockquote><p>记录iOS各种重要里程碑事件</p></blockquote>

<h2>私有成员变量的实现</h2>

<p>1.0时代，在.h文件采用<code>@private</code>关键词</p>

<pre><code>@interface ViewController : UIViewController {
    @private
    NSInteger _value;
}
</code></pre>

<p>2.0时代 通过在.m文件通过<code>匿名Category</code></p>

<pre><code>@interface ViewController ()

@property (nonatomic) NSInteger value;

@end
</code></pre>

<p>3.0时代 2013 年的 WWDC 允许在 .m 的 <code>@implementation</code>中</p>

<pre><code>@implementation ViewController {
    NSInteger _value;
}
</code></pre>

<h2>ARC推出</h2>

<p>2011</p>

<h2>自动生成getter和setter方法的<code>@synthesize</code></h2>

<p>2012</p>

<h2>iOS 2.1 to iOS 2.2 API Differences</h2>

<p>Added frameworks:</p>

<ul>
<li>AVFoundation</li>
</ul>


<h2>iOS 2.2 to iOS 3.0 API Differences</h2>

<p>Added frameworks:</p>

<ul>
<li>CoreData</li>
<li>ExternalAccessory</li>
<li>GameKit</li>
<li>MapKit</li>
<li>MessageUI</li>
<li>MobileCoreServices</li>
<li>StoreKit</li>
</ul>


<h2>iOS 3.2 to iOS 4.0 API Differences</h2>

<p>Added frameworks:</p>

<ul>
<li>Accelerate</li>
<li>AssetsLibrary</li>
<li>CoreMedia</li>
<li>CoreMotion</li>
<li>CoreTelephony</li>
<li>CoreVideo</li>
<li>EventKit</li>
<li>EventKitUI</li>
<li>iAd</li>
<li>ImageIO</li>
<li>QuickLook</li>
</ul>


<h2>iOS 4.3 to iOS 5.0 API Differences</h2>

<p>Added frameworks</p>

<ul>
<li>Accounts</li>
<li>CoreBluetooth</li>
<li>CoreImage</li>
<li>GLKit</li>
<li>GSS</li>
<li>NewsstandKit</li>
<li>Twitter</li>
</ul>


<h2>5.1 to iOS 6.0 API Differences</h2>

<p>Added frameworks</p>

<ul>
<li>AdSupport</li>
<li>MediaToolbox</li>
<li>PassKit</li>
<li>Social</li>
</ul>


<h2>6.1 to iOS 7.0 API Differences</h2>

<p>Added frameworks</p>

<ul>
<li>GameController</li>
<li>JavaScriptCore</li>
<li>MediaAccessibility</li>
<li>MultipeerConnectivity</li>
<li>SafariServices</li>
<li>SpriteKit</li>
</ul>


<h2>iOS 7.1 to iOS 8.0 API Differences</h2>

<p>Added frameworks</p>

<ul>
<li>Accelerate</li>
<li>Accounts</li>
<li>AddressBook</li>
<li>AddressBookUI</li>
<li>AudioToolbox</li>
<li>AudioUnit</li>
<li>AVFoundation</li>
<li>AVKit (Added)</li>
<li>CFNetwork</li>
<li>CloudKit (Added)</li>
<li>CoreAudio</li>
<li>CoreAudioKit (Added)</li>
<li>CoreAuthentication (Added)</li>
<li>CoreBluetooth</li>
<li>CoreData</li>
<li>CoreFoundation</li>
<li>CoreImage</li>
<li>CoreLocation</li>
<li>CoreMedia</li>
<li>CoreMotion</li>
<li>CoreText</li>
<li>CoreVideo</li>
<li>EventKit</li>
<li>EventKitUI</li>
<li>ExternalAccessory</li>
<li>Foundation</li>
<li>GameController</li>
<li>GameKit</li>
<li>GLKit</li>
<li>GSS</li>
<li>HealthKit (Added)</li>
<li>HomeKit (Added)</li>
<li>iAd</li>
<li>ImageIO</li>
<li>IOKit</li>
<li>JavaScriptCore</li>
<li>LocalAuthentication (Added)</li>
<li>MapKit</li>
<li>MediaAccessibility</li>
<li>MediaPlayer</li>
<li>MessageUI</li>
<li>Metal (Added)</li>
<li>MobileCoreServices</li>
<li>MultipeerConnectivity</li>
<li>NetworkExtension (Added)</li>
<li>NewsstandKit</li>
<li>NotificationCenter (Added)</li>
<li>OpenGLES</li>
<li>PassKit</li>
<li>Photos (Added)</li>
<li>PhotosUI (Added)</li>
<li>PushKit (Added)</li>
<li>QuartzCore</li>
<li>QuickLook</li>
<li>SceneKit (Added)</li>
<li>Security</li>
<li>Social</li>
<li>SpriteKit</li>
<li>StoreKit</li>
<li>UIKit</li>
<li>VideoToolbox</li>
<li>WebKit (Added)</li>
</ul>


<h2>iOS 8.3 to iOS 9.0 API Differences</h2>

<p>Added frameworks</p>

<p>Objective-C</p>

<ul>
<li>/usr/include</li>
<li>Accelerate</li>
<li>Accounts</li>
<li>AddressBook</li>
<li>AddressBookUI</li>
<li>AssetsLibrary</li>
<li>AudioToolbox</li>
<li>AudioUnit</li>
<li>AVFoundation</li>
<li>AVKit</li>
<li>CFNetwork</li>
<li>CloudKit</li>
<li>Contacts (Added)</li>
<li>ContactsUI (Added)</li>
<li>CoreAudio</li>
<li>CoreAudioKit</li>
<li>CoreBluetooth</li>
<li>CoreData</li>
<li>CoreFoundation</li>
<li>CoreGraphics</li>
<li>CoreImage</li>
<li>CoreLocation</li>
<li>CoreMedia</li>
<li>CoreMIDI</li>
<li>CoreMotion</li>
<li>CoreSpotlight (Added)</li>
<li>CoreTelephony</li>
<li>CoreText</li>
<li>CoreVideo</li>
<li>EventKit</li>
<li>EventKitUI</li>
<li>ExternalAccessory</li>
<li>Foundation</li>
<li>GameController</li>
<li>GameKit</li>
<li>GameplayKit (Added)</li>
<li>GLKit</li>
<li>GSS</li>
<li>HealthKit</li>
<li>HomeKit</li>
<li>iAd</li>
<li>ImageIO</li>
<li>JavaScriptCore</li>
<li>LocalAuthentication</li>
<li>MapKit</li>
<li>MediaPlayer</li>
<li>MediaToolbox</li>
<li>MessageUI</li>
<li>Metal</li>
<li>MetalKit (Added)</li>
<li>MetalPerformanceShaders (Added)</li>
<li>MobileCoreServices</li>
<li>ModelIO (Added)</li>
<li>MultipeerConnectivity</li>
<li>NetworkExtension</li>
<li>NewsstandKit</li>
<li>OpenAL</li>
<li>PassKit</li>
<li>Photos</li>
<li>PushKit</li>
<li>QuartzCore</li>
<li>QuickLook</li>
<li>ReplayKit (Added)</li>
<li>SafariServices</li>
<li>SceneKit</li>
<li>Security</li>
<li>SpriteKit</li>
<li>StoreKit</li>
<li>SystemConfiguration</li>
<li>UIKit</li>
<li>VideoToolbox</li>
<li>WatchConnectivity (Added)</li>
<li>WatchKit</li>
<li>WebKit</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[优雅处理UIImage图片旋转]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/you-ya-chu-li-uiimagetu-pian-xuan-zhuan/"/>
    <updated>2016-01-13T04:38:49+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/you-ya-chu-li-uiimagetu-pian-xuan-zhuan</id>
    <content type="html"><![CDATA[<h2>UIImag构造方式</h2>

<p>UIImag构造方式大致有4种方式
* 从本地bundle中加载 <code>imageNamed:</code>，传入一个bundle的文件名即可
* 从本地一个文件路径读取 <code>imageWithContentsOfFile:</code>，需要传一个文件的文件路径path
* 通过二进制数据<code>NSData</code>来创建<code>imageWithData:</code>
* 通过一个<code>CoreGraphics</code>的<code>CGImageRef</code>来创建，<code>initWithCGImage:</code>
* 通过一个<code>CoreImage</code>的<code>CIImage</code>来创建<code>initWithCIImage</code></p>

<p>通过查阅Apple官网文档我们发现有2个这样的方法，今天就来一探究竟</p>

<pre><code class="objective-c">+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);
+ (UIImage *)imageWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);

- (instancetype)initWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);
- (instancetype)initWithCIImage:(CIImage *)ciImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(6_0);
</code></pre>

<p>2个类方法2个实例方法都是类似，这里以<code>CGImageRef</code>为例</p>

<pre><code class="objective-c">+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation NS_AVAILABLE_IOS(4_0);
</code></pre>

<ol>
<li>新建的Xcode工程选择single Application</li>
<li>在storyboard中拖一个<code>UIImageView</code>设置它水平垂直居中对齐，宽带高度随便设一个值不要太大就行，设置<code>UIImageView</code>的<code>contentMode</code>为<code>Aspect Fit</code>方便查看以免变形</li>
<li>在<code>UIImageView</code>下发放一个<code>UIButton</code>控件方便后面好对图片进行旋转操作</li>
<li><p>在viewController中建立一个<code>UIImageView</code>引用,拉出一个rotate按钮的<code>IBAction</code></p>

<p> 现在大概界面大概这样
 <img src="http://ww3.sinaimg.cn/mw690/64124373gw1ezhnagzyhpj20x7105doj.jpg" alt="UIImageOrientation效果图" /></p></li>
<li><p>下面我们实现
<code>- (IBAction)rotateImage:(id)sender {}</code>这个方法</p>

<blockquote><p>在这里我们想通过点击按钮实现图片旋转
  为了方便使用我们使用Category的方式实现
  新建一个UIImage的分类取名叫Rotate</p>

<p>这里需要传一张要处理的图片和一个待处理成的图片方向</p>

<pre><code class="``objective-c">  + (UIImage *)rotateImage:(UIImage *)oldImage
           orientation:(UIImageOrientation)orientation;
</code></pre></blockquote>

<pre><code class="``objective-c">  + (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation{

  UIImage *newImage = [UIImage imageWithCGImage:oldImage.CGImage scale:1 orientation:orientation];

  NSString *orientationStr = nil;
  switch (orientation) {
      case UIImageOrientationUp: {
          orientationStr = @"UIImageOrientationUp";
          break;
      }
      case UIImageOrientationDown: {
          orientationStr = @"UIImageOrientationDown";
          break;
      }
      case UIImageOrientationLeft: {
          orientationStr = @"UIImageOrientationLeft";
          break;
      }
      case UIImageOrientationRight: {
          orientationStr = @"UIImageOrientationRight";
          break;
      }
      case UIImageOrientationUpMirrored: {
          orientationStr = @"UIImageOrientationUpMirrored";
          break;
      }
      case UIImageOrientationDownMirrored: {
          orientationStr = @"UIImageOrientationDownMirrored";
          break;
      }
      case UIImageOrientationLeftMirrored: {
          orientationStr = @"UIImageOrientationLeftMirrored";
          break;
      }
      case UIImageOrientationRightMirrored: {
          orientationStr = @"UIImageOrientationRightMirrored";
          break;
      }

  }

  NSLog(@"current orientation: %@",orientationStr);

  return newImage;
}
</code></pre></li>
</ol>


<p>在button点击事件触发时的这样使用</p>

<pre><code class="objective-c">- (IBAction)rotateImage:(id)sender {

    UIImage *oldImage = self.imgView.image;

    UIImage *rotatedImage = [UIImage rotateImage:oldImage orientation:UIImageOrientationLeft];

    self.imgView.image = rotatedImage;
}
</code></pre>

<p>点击按钮测试发现第一次没问题，但是重逢点击无效
原来<code>+ (UIImage *)imageWithCGImage:(CGImageRef)cgImage scale:(CGFloat)scale orientation:(UIImageOrientation)orientation</code>方法执行原理是执行前通过
<code>@property(nonatomic,readonly) UIImageOrientation imageOrientation;</code>接口先判断当前图片的方向是否为将要旋转的方向，
如果是就直接返回不做处理，如果不是再作旋转处理，
也就是说这个方法并没有实际上旋转image的数据，只是用一个枚举标记旋转的状态</p>

<p>如果我们想每次旋转需要直接改变原始image的数据该怎么办呢？
在这里我们通过<code>CGBitmapContext</code>,使用<code>CGContextRotateCTM</code>来设置旋转，
再把UIImage通过<code>drawInRect
</code>重新绘制出来，通过<code>UIGraphicsGetImageFromCurrentImageContext</code>获得处理后的图片
下面是具体实现</p>

<pre><code class="objective-c">- (UIImage *)fixedRotation{
    if (self.imageOrientation == UIImageOrientationUp) return self;
    CGAffineTransform transform = CGAffineTransformIdentity;

    switch (self.imageOrientation) {
        case UIImageOrientationDown:
        case UIImageOrientationDownMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.width, self.size.height);
            transform = CGAffineTransformRotate(transform, M_PI);
            break;

        case UIImageOrientationLeft:
        case UIImageOrientationLeftMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.width, 0);
            transform = CGAffineTransformRotate(transform, M_PI_2);
            break;

        case UIImageOrientationRight:
        case UIImageOrientationRightMirrored:
            transform = CGAffineTransformTranslate(transform, 0, self.size.height);
            transform = CGAffineTransformRotate(transform, -M_PI_2);
            break;
        case UIImageOrientationUp:
        case UIImageOrientationUpMirrored:
            break;
    }

    switch (self.imageOrientation) {
        case UIImageOrientationUpMirrored:
        case UIImageOrientationDownMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.width, 0);
            transform = CGAffineTransformScale(transform, -1, 1);
            break;

        case UIImageOrientationLeftMirrored:
        case UIImageOrientationRightMirrored:
            transform = CGAffineTransformTranslate(transform, self.size.height, 0);
            transform = CGAffineTransformScale(transform, -1, 1);
            break;
        case UIImageOrientationUp:
        case UIImageOrientationDown:
        case UIImageOrientationLeft:
        case UIImageOrientationRight:
            break;
    }

    // Now we draw the underlying CGImage into a new context, applying the transform
    // calculated above.
    CGContextRef ctx = CGBitmapContextCreate(NULL, self.size.width, self.size.height,
                                             CGImageGetBitsPerComponent(self.CGImage), 0,
                                             CGImageGetColorSpace(self.CGImage),
                                             CGImageGetBitmapInfo(self.CGImage));
    CGContextConcatCTM(ctx, transform);
    switch (self.imageOrientation) {
        case UIImageOrientationLeft:
        case UIImageOrientationLeftMirrored:
        case UIImageOrientationRight:
        case UIImageOrientationRightMirrored:
            // Grr...
            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.height,self.size.width), self.CGImage);
            break;

        default:
            CGContextDrawImage(ctx, CGRectMake(0,0,self.size.width,self.size.height), self.CGImage);
            break;
    }

    // And now we just create a new UIImage from the drawing context
    CGImageRef cgimg = CGBitmapContextCreateImage(ctx);
    UIImage *img = [UIImage imageWithCGImage:cgimg];
    CGContextRelease(ctx);
    CGImageRelease(cgimg);
    return img;

}
</code></pre>

<p>现在再优化一下原来<code>+ (UIImage *)rotateImage:(UIImage *)oldImage orientation:(UIImageOrientation)orientation</code> 方法,修改成这样
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
</pre></td><td class='code'><pre><code class='objective-c'><span class='line'><span class="p">+</span> <span class="p">(</span><span class="bp">UIImage</span> <span class="o">&lt;</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nf">rotateImage:</span><span class="p">(</span><span class="bp">UIImage</span> <span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">oldImage</span> <span class="nf">orientation:</span><span class="p">(</span><span class="n">UIImageOrientation</span><span class="p">)</span><span class="nv">orientation</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UIImage</span> <span class="o">*</span><span class="n">newImage</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIImage</span> <span class="nl">imageWithCGImage</span><span class="p">:</span><span class="n">oldImage</span><span class="p">.</span><span class="bp">CGImage</span> <span class="nl">scale</span><span class="p">:</span><span class="mi">1</span> <span class="nl">orientation</span><span class="p">:</span><span class="n">orientation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//fix original Image with gived orientation.</span>
</span><span class='line'><span class="bp">UIImage</span> <span class="o">*</span><span class="n">fixedRotationImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">newImage</span> <span class="n">fixedRotation</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="bp">NSString</span> <span class="o">*</span><span class="n">orientationStr</span> <span class="o">=</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'><span class="k">switch</span> <span class="p">(</span><span class="n">orientation</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationUp</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationUp&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationDown</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationDown&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationLeft</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationLeft&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationRight</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationRight&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationUpMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationUpMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationDownMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationDownMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationLeftMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationLeftMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">case</span> <span class="nl">UIImageOrientationRightMirrored</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">orientationStr</span> <span class="o">=</span> <span class="s">@&quot;UIImageOrientationRightMirrored&quot;</span><span class="p">;</span>
</span><span class='line'>        <span class="k">break</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;current orientation: %@&quot;</span><span class="p">,</span><span class="n">orientationStr</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'><span class="k">return</span> <span class="n">fixedRotationImage</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>
 现在再测试一下，well，It‘s OK。</p>

<p> have fun!!!</p>

<p>参考资料：
* <a href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIImage_Class/#//apple_ref/c/tdef/UIImageOrientation">Apple-UIImage Class Reference</a>
* <a href="http://stackoverflow.com/questions/8915630/ios-uiimageview-how-to-handle-uiimage-image-orientation">ios-uiimageview-how-to-handle-uiimage-image-orientation</a>
* <a href="http://www.galloway.me.uk/2012/01/uiimageorientation-exif-orientation-sample-images/">UIImageOrientation / EXIF orientation sample images</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[动画绘制CAShapeLayer的路径CGPath]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath/"/>
    <updated>2016-01-13T04:35:42+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/dong-hua-hui-zhi-cashapelayerde-lu-jing-cgpath</id>
    <content type="html"><![CDATA[<h1>Animating the Drawing of a CGPath With CAShapeLayer</h1>

<ul>
<li><a href="http://oleb.net/blog/2010/12/animating-drawing-of-cgpath-with-cashapelayer/">原文链接</a></li>
</ul>


<h1>这是什么？</h1>

<blockquote><p>此文将讲解通过形状图层<code>CAShaperLayer</code>的<code>strokeStart</code>和<code>strokeEnd</code>来实现动画绘制路径<code>CGPath</code>,此文是<a href="http://oleb.net">By Ole Begemann</a>创建于December 18, 2010,当时是发布iOS SDK 4.2时<code>CAShapeLayer</code>新增加的两个属性<a href="http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html#//apple_ref/doc/uid/TP40008314-CH1-SW16">strokeStart</a>和<a href="http://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CAShapeLayer_class/Reference/Reference.html#//apple_ref/doc/uid/TP40008314-CH1-SW15">strokeEnd</a>,这两个值是两个浮点数取值范围0.0~1.0,用来表明形状图层所指向的路径在绘制开始和结束路径中的相对位置。</p></blockquote>

<p><code>strokeStart</code>默认值是0.0，<code>strokeEnd</code>默认值是1.0，显然这会导致形状图层的路径将一整个被绘制。假如，你想说，如果设置了layer.strokeEnd = 0.5f,只让她绘制前半部分，那该多好。</p>

<p>真正有趣的事情是这些接口都是可动画的。通过动画绘制<code>strokeEnd</code>从0.0到1.0在几秒内，我们就能很容易自己绘制路径像下面这样写：</p>

<pre><code class="objective-c">CABasicAnimation *pathAnimation = [CABasicAnimation animationWithKeyPath:@"strokeEnd"];
pathAnimation.duration = 10.0;
pathAnimation.fromValue = [NSNumber numberWithFloat:0.0f];
pathAnimation.toValue = [NSNumber numberWithFloat:1.0f];
[self.pathLayer addAnimation:pathAnimation forKey:@"strokeEndAnimation"];
</code></pre>

<p>最后，再添加第二个图层包含一个铅笔图片，使用关键帧动画<code>CAKeyframeAnimation</code>来让它随着这个路径以相同的速度绘制，就可以达到完美的错觉效果：</p>

<pre><code class="objective-c">CAKeyframeAnimation *penAnimation = [CAKeyframeAnimation animationWithKeyPath:@"position"];
penAnimation.duration = 10.0;
penAnimation.path = self.pathLayer.path;
penAnimation.calculationMode = kCAAnimationPaced;
[self.penLayer addAnimation:penAnimation forKey:@"penAnimation"];
</code></pre>

<p><a href="http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4">绘制普通路径效果视频</a></p>

<p><a href="http://oleb.net/media/AnimatedPathsHausVomNikolaus.mp4">下载地址</a></p>

<p>这个对文本一样有效；我们只需要把字符转化成<code>CGPath</code>。<code>Core Text</code>提供了那样的功能的函数，<a href="http://developer.apple.com/library/ios/documentation/Carbon/Reference/CTFontRef/Reference/reference.html#//apple_ref/c/func/CTFontCreatePathForGlyph">CTFontCreatePathForGlyph( )</a>。为了使用它，我们需要创建一个带属性的字符串用我们想要渲染的文本，先把它们分割成行在分割成一个个字符。在把所有的字符转换成路径后，我们以子路径方式把它添加到一个单个的<code>CGPath</code>路径中。更多细节可以查看<a href="http://www.codeproject.com/script/Membership/View.aspx?mid=2887692">Ohmu</a>写的<a href="http://www.codeproject.com/KB/iPhone/Glyph.aspx">Low-level text rendering</a>这篇文章。结果看以来非常的炫酷：</p>

<p><a href="http://oleb.net/media/AnimatedPathsHelloWorld.mp4">绘制文字路径效果视频</a></p>

<p><a href="http://oleb.net/media/AnimatedPathsHelloWorld.mp4">下载地址</a></p>

<p>从Github上获得<a href="http://github.com/ole/Animated-Paths">iPad版的样品工程</a></p>

<h1>你将学到的知识点</h1>

<ul>
<li>使用<code>CAShapeLayer</code>的<code>strokeStart</code>和<code>strokeEnd</code>来实现路径动画,比较高级复杂的效果像google的下拉刷新转圈就可以从这里引申去实现。</li>
<li><code>CABasicAnimation</code>和<code>CABasicAnimation</code>使用</li>
<li>深入理解<code>CAShapeLayer</code>和<code>CALayer</code></li>
<li>通过文本创建路径，核心函数<code>CTFontCreatePathForGlyph()</code></li>
</ul>


<h1>补充说明</h1>

<pre><code class="objective-c">    CAShapeLayer *pathLayer = [CAShapeLayer layer];
    pathLayer.frame = self.animationLayer.bounds;
    pathLayer.bounds = pathRect;
    pathLayer.geometryFlipped = YES;
    pathLayer.path = path.CGPath;
    pathLayer.strokeColor = [[UIColor blackColor] CGColor];
    pathLayer.fillColor = nil;
    pathLayer.lineWidth = 10.0f;
    pathLayer.lineJoin = kCALineJoinBevel;

    [self.animationLayer addSublayer:pathLayer];
</code></pre>

<p>有一点非常重要，CALayer在iOS系统中相对坐标系是以屏幕左上<code>top-left</code>为坐标原点的，在Mac OS X上以坐下<code>bottom-left</code>为坐标原点,但是可以通过<code>CALayer</code>的接口<code>geometryFlipped</code>垂直翻转坐标系，这个值默认是<code>NO</code>，设置成<code>YES</code>就可以把坐标系转换成左下<code>bottom-left</code>了，这里作者使用的左下<code>bottom-left</code>的坐标系。</p>

<pre><code class="objective-c">@property(getter=isGeometryFlipped) BOOL geometryFlipped;
</code></pre>

<p>关于这个属性使用时需要特别注意</p>

<ol>
<li>翻转会同时作用于它的子图层</li>
<li>即使这个属性设置成<code>YES</code>,图片的<code>orientation</code>仍然是不变的（也就是说当设置<code>flipped=YES</code>和<code>flipped=NO</code>时一个<code>CGImageRef</code>储存在<code>contents</code>接口中的内容将会显示一致，赋值并不会真正变换底层的图层）</li>
</ol>


<h3>pathLayer动画实现原理</h3>

<ol>
<li>先创建一个动画用的图层<code>animationLayer</code>类型<code>CALayer</code>，用来充当动画的画布。</li>
<li>创建真正的路径图层<code>pathLayer</code>类型为<code>CAShapeLayer</code>,让它的坐标系垂直翻转，并且让图层宽高同时向内收缩100个点,通过<code>CGRectInset(CGRect rect, CGFloat dx, CGFloat dy)</code>实现</li>
<li>把<code>pathLayer</code>添加到<code>animationLayer</code>的子图层中去</li>
<li>创建一个铅笔图层<code>penLayer</code>类型为<code>CALayer</code>,把它添加到<code>pathLayer</code>去</li>
<li>对<code>pathLayer</code>添加<code>CABasicAnimation</code>动画，动画属性为<code>strokeEnd</code></li>
<li>对<code>penLayer</code>添加<code>CAKeyframeAnimation</code>动画，动画属性为<code>position</code></li>
</ol>


<h3>textLayer动画实现原理</h3>

<ol>
<li>先创建一个动画用的图层<code>animationLayer</code>类型<code>CALayer</code>，用来充当动画的画布</li>
<li>Create path from text,See:<a href="http://www.codeproject.com/KB/iPhone/Glyph.aspx">http://www.codeproject.com/KB/iPhone/Glyph.aspx</a>，最终保存到一个类型为<code>CGMutablePathRef</code>的letter中</li>
<li>通过letter来创建文字<code>UIBezierPath</code>类型的<code>path</code></li>
<li>通过path再创建<code>CAShapeLayer</code>pathLayer,并且把pathLayer添加到<code>animationLayer</code>中去</li>
<li>创建一个铅笔图层<code>penLayer</code>类型为<code>CALayer</code>,把它添加到<code>pathLayer</code>去</li>
<li>对<code>pathLayer</code>添加<code>CABasicAnimation</code>动画，动画属性为<code>strokeEnd</code></li>
<li>对<code>penLayer</code>添加<code>CAKeyframeAnimation</code>动画，动画属性为<code>position</code></li>
</ol>


<h3>修复一处bug</h3>

<p>重复点击<code>UISegmentedControl</code>导致铅笔消失，这是设置了<code>penAnimation.delegate = self;</code>在代理方法里面没有判断结束直接将设置<code>self.penLayer.hidden = YES</code>，导致连续切换时铅笔不见了，要修复这个bug只需加一个判断<code>   if (flag)   self.penLayer.hidden = YES;
</code>即可,这样的意思是只有当动画完成时才设置<code>self.penLayer.hidden</code>的值，好了现在已经非常完美了，快去动手自己试试吧！🍺</p>
]]></content>
  </entry>
  
</feed>
