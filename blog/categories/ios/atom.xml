<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ios | 王若风的小窝]]></title>
  <link href="http://wangruofeng.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://wangruofeng.github.io/"/>
  <updated>2016-01-13T04:34:54+08:00</updated>
  <id>http://wangruofeng.github.io/</id>
  <author>
    <name><![CDATA[Ace]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS中的触摸事件和手势处理]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li/"/>
    <updated>2016-01-13T04:34:00+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/ioszhong-de-hong-mo-shi-jian-he-shou-shi-chu-li</id>
    <content type="html"><![CDATA[<h3>iOS触摸事件分类</h3>

<ul>
<li>触摸事件</li>
<li>加速事件</li>
<li>远程事件</li>
</ul>


<h3>谁能处理触摸事件?</h3>

<p><strong>响应者对象</strong></p>

<p>在iOS中不是任何对象都能处理事件,只有继承了UIResponder的对象才能接收并处理事件.我们称之为<strong>响应者对象</strong>.</p>

<p><code>UIApplication</code>,<code>UIViewController</code>,<code>UIView</code>都继承自<code>UIResponder</code>,因此它们都是响应者对象,都能够接收并处理事件.</p>

<h3>UIResponder</h3>

<p>UIResponder内部提供了方法来处理事件</p>

<ol>
<li><p>触摸事件</p>

<p> 一次完成的触摸过程,会经历3个状态;
 UIView的触摸事件处理</p>

<p> 1.一根或多根手指开始触摸view,系统会自动调用view下面的方法:</p>

<pre><code> - (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸开始
</code></pre>

 2.一根或者多根手指在view上移动，系统会自动调用view下面的方法（随着手指的移动，会持续调用该方法）

<pre><code> - (void)touchesMoved:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸移动
</code></pre>

 3.一根或者多根手指离开view，系统会自动调用view下面的方法

<pre><code> - (void)touchesEnded:(NSSet *)touches withEvent:(UIEvent *)event;  //触摸结束
</code></pre>

 4.触摸结束前，某个系统事件（例如电话呼入 ）会打断触摸过程，系统会自动调用view下面的方法

<pre><code> - (void)touchesCancelled:(NSSet *)touches withEvent:(UIEvent *)event; //触摸取消(可能会经历)
</code></pre>

 4个触摸事件的处理方法中，都有 NSSet <em>touches 和 UIEvent </em>event 两个参数:

<ul>
<li>一次完整的触摸过程，只会产生一个事件对象，4个触摸方法都是同一个event参数</li>
<li>如果两根手指同时触摸一个view，那么view只会调用一次 touchesBegan:withEvent: 方法，touches参数中装着两个UITouch对象；</li>
<li>如果这两根手指一前一后分开触摸同一个view，那么view会分别调用两次 touchesBegan:withEvent:方法， 并且每次调用时的touches参数只包含一个UITouch对象；</li>
<li>根据touches中UITouch个数可以判断出使单点触摸还是多点触摸</li>
</ul>


<p> 提示：touches中存放的都是UITouch对象。</p></li>
<li><p>加速计事件</p>

<pre><code> - (void)motionBegan:(UIEventSubtype)motion withEvent:(UIEvent *)event;
 - (void)motionEnded:(UIEventSubtype)motion withEvent:(UIEvent *)event;
 - (void)motionCancelled:(UIEventSubtype)motion withEvent:(UIEvent *)event;
</code></pre></li>
<li><p>远程控制事件</p>

<pre><code> - (void)remoteControlReceivedWithEvent:(UIEvent *)event;
</code></pre></li>
</ol>


<h3>UITouch</h3>

<p>当用户用一根手指触摸屏幕时，会创建一个与手指相关联的UITouch对象；一根手指对应一个UITouch对象
UITouch的作用:</p>

<ul>
<li>保存跟手指相关的信息，比如触摸的位置、时间、阶段；</li>
<li>当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指的触摸位置；</li>
<li>当手指离开屏幕时，系统会销毁相应的UITouch对象。</li>
</ul>


<p>提示：iPhone开发中，要避免使用双击事件。</p>

<p>UITouch的属性:
触摸产生时所处的窗口:</p>

<pre><code>@property(nonatomic,readonly,retain) UIWindow *window;
</code></pre>

<p>触摸产生时所处的视图</p>

<pre><code> @property(nonatomic,readonly,retain) UIView *view;
</code></pre>

<p>短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多地点击</p>

<pre><code> @property(nonatomic,readonly) NSUInteger tapCount;
</code></pre>

<p>记录了触摸事件产生或变化时的时间，单位是秒</p>

<pre><code> @property(nonatomic,readonly) NSTimeInterval timestamp;
</code></pre>

<p>当前触摸事件所处的状态</p>

<pre><code>@property(nonatomic,readonly) UITouchPhase phase;
/*
UITouchPhase是一个枚举类型，包含：
UITouchPhaseBegan（触摸开始）
UITouchPhaseMoved（接触点移动）
UITouchPhaseStationary（接触点无移动）
UITouchPhaseEnded（触摸结束）
UITouchPhaseCancelled（触摸取消）*/
</code></pre>

<p>UITouch的方法：</p>

<pre><code>- (CGPoint)locationInView:(UIView *)view;
</code></pre>

<p>1.返回值表示触摸在view上的位置；</p>

<p>2.这里返回的位置是针对view坐标系的,（以view的左上角为原点（0，0））；</p>

<p>3.调用时传入的view参数为nil 的话，返回的是触摸点在UIWindow的位置。</p>

<pre><code>- (CGPoint)previousLocationInView:(UIView *)view;
</code></pre>

<p>该方法记录了前一个触摸点的位置；</p>

<h3>UIEvent</h3>

<blockquote><p>每产生一个事件，就会产生一个UIEvent对象；</p>

<p>UIEvent:称为事件对象，记录事件产生的时刻和类型。</p></blockquote>

<p>常见属性：
1.事件类型</p>

<pre><code class="objective-c">@property(nonatomic,readonly) UIEventType  type;
@property(nonatomic,readonly) UIEventSubtype  subtype;

typedef
NS_ENUM(NSInteger, UIEventType) {
    UIEventTypeTouches,
    UIEventTypeMotion,
    UIEventTypeRemoteControl,
};
typedef
NS_ENUM(NSInteger, UIEventSubtype) {
    // available in iPhone OS 3.0
    UIEventSubtypeNone                              = 0,    
    // for UIEventTypeMotion, available in iPhone OS 3.0
    UIEventSubtypeMotionShake                       = 1,
    // for UIEventTypeRemoteControl, available in iOS 4.0
    UIEventSubtypeRemoteControlPlay                 = 100,
    UIEventSubtypeRemoteControlPause                = 101,
    UIEventSubtypeRemoteControlStop                 = 102,
    UIEventSubtypeRemoteControlTogglePlayPause      = 103,
    UIEventSubtypeRemoteControlNextTrack            = 104,  
    UIEventSubtypeRemoteControlPreviousTrack        = 105,
    UIEventSubtypeRemoteControlBeginSeekingBackward = 106,   
    UIEventSubtypeRemoteControlEndSeekingBackward   = 107,  
    UIEventSubtypeRemoteControlBeginSeekingForward  = 108,  
    UIEventSubtypeRemoteControlEndSeekingForward    = 109,
};
</code></pre>

<p>2.事件产生的时间</p>

<pre><code>@property(nonatomic,readonly) NSTimeInterval  timestamp;
</code></pre>

<p> UIEvent还提供了相应的方法可以获得在某个view上面的触摸对象（UITouch）。</p>

<p> 触摸事件的产生：</p>

<ol>
<li><p>发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中；</p></li>
<li><p>UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）；</p></li>
<li><p>主窗口会在视图层次结构中找到一个最合适的视图控件来处理触摸事件，这也是整个事件处理过程的第一步；</p></li>
<li><p>找到合适的视图控件后，就会调用视图控件的touches方法来做具体的事件处理。</p></li>
</ol>


<p>触摸事件的传递：</p>

<blockquote><p>触摸事件的传递是从父控件传递到子控件；</p>

<p>如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件。</p></blockquote>

<p><img src="http://ww4.sinaimg.cn/mw690/64124373gw1eznrp087anj205t07rdfx.jpg" alt="触摸事件" />
<img src="http://ww2.sinaimg.cn/mw690/64124373gw1eznrrf36ymj2097077dhc.jpg" alt="触摸事件2" /></p>

<p>UIView不接收触摸事件的三种情况:
不接受用户交互 ：</p>

<ol>
<li><p>userInteractionEnable = NO;</p></li>
<li><p>隐藏 ：hidden = YES;</p></li>
<li><p>透明：alpha = 0.0 ~ 0.01</p></li>
</ol>


<p>提示：UIImageView的userInteractionEnable默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的。</p>

<p>触摸事件处理的详细过程：</p>

<ol>
<li><p>用户点击屏幕后产生的一个触摸事件，经过一些列的传递过程后，会找到最合适的视图控件来处理这个事件</p></li>
<li><p>找到最合适的视图控件后，就会调用控件的touches方法来作具体的事件处理</p>

<p> touchesBegan…</p>

<p> touchesMoved…</p>

<p> touchedEnded…</p></li>
</ol>


<p>这些touches方法的默认做法是将事件顺着响应者链条向上传递，将事件交给上一个响应者进行处理</p>

<p>响应者链的事件传递过程：</p>

<ol>
<li><p>如果view的控制器存在，就传递给控制器；如果控制器不存在，则将其传递给它的父视图；</p></li>
<li><p>在视图层次结构最顶级的视图，如果也不能处理收到的事件或消息，则其将事件或消息传递给window对象进行处理。</p></li>
<li><p>如果window对象也不处理，则其将事件或消息传递给UIApplication对象；</p></li>
<li><p>如果UIApplication也不能处理该事件或消息，则将其丢弃</p></li>
</ol>


<h3>监听触摸事件的做法</h3>

<p>如果想监听一个view上面的触摸事件，之前的做法是：</p>

<ol>
<li><p>自定义一个view；</p></li>
<li><p>实现view的touches方法，在方法内部实现具体处理代码。</p>

<p> 通过touches方法监听view触摸事件，有很明显的几个缺点：</p>

<ul>
<li><p>必须得自定义view；</p></li>
<li><p>由于是在view内部的touches方法中监听触摸事件，因此默认情况下，无法让其他外界对象监听view的触摸事件；</p></li>
<li><p>不容易区分用户的具体手势行为。</p></li>
</ul>
</li>
</ol>


<p>iOS 3.2之后，苹果推出了手势识别功能（Gesture Recognizer）,在触摸事件处理方面，大大简化了开发者的开发难度。</p>

<h3>UIGestureRescognizer</h3>

<p>为了完成手势识别，必须借助于手势识别器：UIGestureRecognizer 。</p>

<p>利用UIGestureRecognizer,能轻松识别用户在某个view上面做的一些常见手势。</p>

<p>UIGestureRecognizer是一个抽象类，定义了所有的手势基本行为，使用它的子类才能处理具体的手势</p>

<ul>
<li>UITapGestureRecognizer(敲击)</li>
<li>UIPinchGestureRecognizer(捏合，用于缩放)</li>
<li>UIPanGestureRecognizer(拖拽)</li>
<li>UISwipeGestureRecognizer(轻扫)</li>
<li>UIRotationGestureRecognizer(旋转)</li>
<li>UILongPressGestureRecognizer(长按)</li>
</ul>


<p>每一个手势识别器的用法都差不多，比如UITapGestureRecognizer的使用步骤如下:</p>

<ol>
<li><p>创建手势识别器对象；</p>

<p> UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc] init];</p></li>
<li><p>设置手势识别器对象的具体属性；</p>

<pre><code> // 连续敲击2次
 tap.numberOfTapsRequired = 2;
 // 需要2根手指一起敲击
 tap.numberOfTouchesRequired = 2;
</code></pre></li>
<li><p>添加手势识别器到对应的view上</p>

<p> [self.iconView addGestureRecognizer:tap];</p></li>
<li><p>监听手势的触发</p>

<p> [tap addTarget:self action:@selector(tapIconView:)];</p></li>
</ol>


<p>手势识别的状态</p>

<pre><code class="objective-c">typedef NS_ENUM(NSInteger, UIGestureRecognizerState) {
    // 没有触摸事件发生，所有手势识别的默认状态
    UIGestureRecognizerStatePossible,
    // 一个手势已经开始但尚未改变或者完成时
    UIGestureRecognizerStateBegan,
    // 手势状态改变
    UIGestureRecognizerStateChanged,
    // 手势完成
    UIGestureRecognizerStateEnded,
    // 手势取消，恢复至Possible状态
    UIGestureRecognizerStateCancelled,
    // 手势失败，恢复至Possible状态
    UIGestureRecognizerStateFailed,
    // 识别到手势识别
    UIGestureRecognizerStateRecognized = UIGestureRecognizerStateEnded
};
</code></pre>

<p>参考资料：<a href="http://my.oschina.net/aofe/blog/268749">傲风凌寒的博客</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[__autoreleasing的理解]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/autoreleasingde-li-jie/"/>
    <updated>2016-01-13T04:27:10+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/autoreleasingde-li-jie</id>
    <content type="html"><![CDATA[<h3>__autoreleasing 修饰符</h3>

<p>将对象赋值给附有__autoreleasing 修饰符的变量等同于ARC 无效时调用对象的autorelease方法。我们通过以下源代码来看一下</p>

<pre><code class="objective-c">@autoreleasepool {
id __autoreleasing obj  = [[NSObject alloc] init];
}
</code></pre>

<p>该源代码主要将NSObject 类对象注册到autoreleasepool 中，可作如下变换：</p>

<pre><code class="objective-c">/* 编译器的模拟代码 */
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSObject, @selector(alloc));
objc_msgSend(obj, @selector(init));
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);
</code></pre>

<p>这与苹果的autorelease 实现中的说明（参考1.2.7 节）完全相同。虽然ARC 有效和无效时，其在源代码上的表现有所不同，但autorelease 的功能完全一样。</p>

<p>在alloc/new/copy/mutableCopy 方法群之外的方法中使用注册到autoreleasepool 中的对象会如何呢？下面我们来看看NSMutableArray 类的array 类方法。</p>

<pre><code class="objective-c">@autoreleasepool {
id __autoreleasing obj = [NSMutableArray array];
}
</code></pre>

<p>这与前面的源代码有何不同呢？</p>

<pre><code class="objective-c">/* 编译器的模拟代码 */
id pool = objc_autoreleasePoolPush();
id obj = objc_msgSend(NSMutableArray, @selector(array));
objc_retainAutoreleasedReturnValue(obj);
objc_autorelease(obj);
objc_autoreleasePoolPop(pool);
</code></pre>

<p>虽然持有对象的方法从alloc 方法变为objc_retainAutoreleasedReturnValue 函数， 但注册autoreleasepool 的方法没有改变，仍是objc_autorelease 函数。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[__attribute__]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/attribute/"/>
    <updated>2016-01-13T04:10:33+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/attribute</id>
    <content type="html"><![CDATA[<ul>
<li>译自 Written by <a href="http://nshipster.com/authors/mattt-thompson/">Mattt Thompson</a> — January 14th, 2013</li>
<li>原文链接：<a href="http://nshipster.com/__attribute__/">http://nshipster.com/__attribute__/</a></li>
<li>译者<a href="https://twitter.com/oneruofeng">@oneruofeng</a></li>
</ul>


<p>重复发布这个主题已经说明了同编译器保存健康关系的重要性,像任何草稿一样，作为一个实践者的效率取决于他们怎样对待他们的工具，你照顾好它们，它们反过来也会对你有好处。</p>

<p> <code>__attribute__</code>是一个编译器的指令在声明的时候指明了一些参数，这些参数允许更多的检查错误和高级的优化。</p>

<p> 语法关键字是<code>__attribute__</code>紧跟2套圆括号（双圆括号让出现的宏更容易辨认，特别是在有多个属性的时候）。在括号内部是一个以逗号分隔的属性列表，<code>__attribute__</code>指令被放在函数，变量和类型声明后面。</p>

<pre><code class="objective-c"> // Return the square of a number
int square(int n) __attribute__((const));

// Declare the availability of a particular API
void f(void)
  __attribute__((availability(macosx,introduced=10.4,deprecated=10.6)));

// Send printf-like message to stderr and exit
extern void die(const char *format, ...)
  __attribute__((noreturn, format(printf, 1, 2)));
</code></pre>

<p>假如这个让你想起ISO C语言的 <code>#pragma</code>,你就不会感到孤单了。</p>

<p>实际上，当<code>__attribute__</code>被第一次引入到<code>GCC</code>编译器时，它面临一些阻力，有人建议使用专用的<code>#pragma</code>因为相同的目的。</p>

<p>这里，然而，有2个非常好的理由为什么<code>__attribute__</code>被添加进来</p>

<blockquote><ul>
<li>从一个宏中产生<code>#pragma</code>命令几乎是不能的（在C99 _Pragma 预算符以前）。</li>
<li>这里没人知道相同的<code>#pragma</code>在另一个编译器中可能的意思。</li>
</ul>
</blockquote>

<p> 引用<a href="http://gcc.gnu.org/onlinedocs/gcc/Function-Attributes.html">GCC Documentation for Function Attributes</a></p>

<blockquote><ul>
<li>这里有2个原因被应用到几乎所有的应用推荐使用<code>#pragma</code>,这犯了一个低级错误就是把<code>#pragma</code>使用到任何地方。</li>
</ul>
</blockquote>

<p> 确实，假如你在苹果的框架中和牛逼工程师的开源项目中的头文件看一下现代的<code>Objective-c</code>&ndash;<code>__attribute__</code>被大量使用。（相反，<code>#pragma</code>的主要声明名声来着这些天是装饰:<code>#pragma mark</code>）</p>

<p> 所以为了以后不费力，我们还是先看一下最重要的属性：</p>

<hr />

<h2>GCC</h2>

<p><strong>format</strong></p>

<blockquote><p><code>format</code>属性指定了一个函数像<code>printf</code>,<code>scanf</code>,<code>strftime</code>或者<code>strfmo</code>风格的参数，这个参数应该是可以进行类型检查的一个格式化字符串。</p></blockquote>

<pre><code class="objective-c">extern int
my_printf (void *my_object, const char *my_format, ...)
  __attribute__((format(printf, 2, 3)));
</code></pre>

<p>Objective-C程序员也可使用<code>__NSString__</code>来格式化来做到相同的格式化规则，像在<code>NNString</code>中通过 <code>+stringWithFormat:</code> 和 <code>NSLog()</code>格式化字符串一样。</p>

<p><strong>nonnull</strong></p>

<blockquote><p>这个<code>nonnull</code>属性指定了某些函数的参数必须是非空的指针。</p></blockquote>

<pre><code class="objective-c">extern void *
my_memcpy (void *dest, const void *src, size_t len)
  __attribute__((nonnull (1, 2)));
</code></pre>

<p>使用<code>nonnull</code>编码期望这个值遵守一个明确的约定中，这样能帮助捕获潜伏在任何代码调用的NULL指针bugs，请记住：
<code>编译时的错误 &gt;&gt;  运行时的错误。</code></p>

<p><strong>noreturn</strong></p>

<blockquote><p>一些标准库函数，例如<code>abort</code>和<code>exit</code>,是不能返回的。GCC自动知道这些东西，这个noreturn属性用于指定任何其他函数永远不会返回的情况。</p></blockquote>

<p>例如，AFNetworking 使用<code>noreturn</code>属性在它的<a href="https://github.com/AFNetworking/AFNetworking/blob/1.1.0/AFNetworking/AFURLConnectionOperation.m#L157">网络请求线程进入点的方法</a>里面,这个方法用在当大量产生专用的网络的线程里用来保证分离的线程持续执行在应用的整个生命周期中。</p>

<p><strong>pure/const</strong></p>

<blockquote><p><code>pure</code>属性指定了一个函数除了返回值没有副作用，例如它的返回值仅仅依赖参数和/或者全局变量。这样的函数可以用公共子表达式消除并且循环优化就像一个算数操作符那样。</p>

<p><code>pure</code>属性指定了一个函数不会检查任何值除了它们的参数，并且返回值没有副作用。注意到一个函数有一个指针参数并且需呀检查数据的指向不能声明成<code>const</code>。同样的，一个函数调用一个非<code>nonst</code>函数通常不能为<code>const</code>,一个<code>const</code>函数返回<code>void</code>并没有什么意义。</p></blockquote>

<pre><code class="objective-c">int square(int n) __attribute__((const));
</code></pre>

<p><code>pure</code>和<code>const</code>是两个执行在一个函数式编程惯例中的参数为了允许有效性能优化。<code>const</code>可以被认为是严格形式的<code>pure</code>因为它不依赖全局变量或者指针。</p>

<p>例如，因为一个函数声明为<code>const</code>的结果并不依赖任何东西除了传进来的参数。函数的结果能够缓存那个结果并且当函数被调用时返回，这样的函数叫做相同的组合参数（也就是说，我们知道一个数字的平方是一个常量，所以我们仅仅需要只计算它一次)。</p>

<p><strong>unused</strong></p>

<blockquote><p>这个属性，附着在一个函数后面，意味着那个函数很可能不会被使用，GCC不会对这个函数产生警告。</p></blockquote>

<p>用<code>__unused</code>关键词可以获得相同的效果，声明这个在方法实现中不会被使用的参数中。知道那以后一些上下文就可以允许编译器来做相应的优化。你很可能喜欢在delegate方法实现李勉使用<code>__unused</code>,因为协议频繁的提高更多的上下文比通常必要的情况，为了满足大量的潜在使用案例。</p>

<h3>LLVM</h3>

<p>像GCC的很多特征一样，Clang也支持<code>__attribute__</code>,添加到它自己的小范围的扩展。为了检查某个属性的可用性，你可以直接使用<code>__has_attribute</code>属性。</p>

<p><strong>availability</strong></p>

<blockquote><p>Clang引进了availability属性，这个可以被取代在声明描述的生命周期中声明相对于操作系统的版本。思考对一个简单函数f：的函数声明</p></blockquote>

<pre><code class="objective-c">void f(void) __attribute__((availability(macosx,introduced=10.4,deprecated=10.6,obsoleted=10.7)));
</code></pre>

<blockquote><p><code>availability</code>属性声明f在OS X老虎系统中被引入，在OS X雪豹系统中被弃用，在OS X 山狮系统中被废弃。</p>

<p>这个信息被Clang用来决定什么时候使用f：函数式安全的，例如，假如Clang在OS X 美洲豹系统上编译，调用f()函数将成功。假如Clang在OS X雪豹系统中编译，函数调用将成功但是Clang会发出一个警告指明这个函数被弃用了。最后，假如Clang被引进编译OS X山狮系统的代码，函数调用将失败，因为f()函数已经不再可用了。</p>

<p><code>availability</code>属性是一个逗号分隔的列表以平台名开始然后引入一些定语列举出生命周期内的重要里程碑事件附加额外的信息（以任何顺序）。</p></blockquote>

<ul>
<li>introduced：声明被引入的第一个版本</li>
<li>deprecated：声明被弃用的第一个版本，这意味着用户应该把这个API移走</li>
<li>obsoleted： 声明被废弃的第一个版本，这意味着它将被完全移除并且不能再使用</li>
<li>unavailable：声明在这个平台上将永远不可用</li>
<li>message：额外的消息将被Clang提供当忽略一个警告或者一个错误在使用一个被弃用或者被废弃的声明。对引导用户替换APIs很有用。</li>
</ul>


<blockquote><p>在声明时可以使用多个availability属性，每个对应不同的平台，仅当availability属性对应相应的目标平台被使用的时候，任何其他才将被忽略。假如没有availability 属性指定可用性对现在的目标平台，availability 属性将被忽略。</p></blockquote>

<h4>支持的平台：</h4>

<ul>
<li>ios：苹果的iOS操作系统。最小的部署目标被指定通过<code>-mios-version-min=*version*</code>或者<code>-miphoneos-version-min=*version*</code>命令行参数。</li>
<li>macosx：苹果的OS X 操作系统，最小的部署目标被指定通过<code>-mmacosx-version-min=*version*</code>命令行参数</li>
</ul>


<p><strong>overloadable</strong></p>

<blockquote><p>Clang提供对C++函数在C中重载的支持。在C中函数重载被引进使用<code>overloadable</code>属性。例如，一个可能提供一个重载版本的<code>tgsin</code>函数来精确执行相关的标准函数计算<code>float</code>,<code>double</code>,<code>long double</code>的正弦值：</p></blockquote>

<pre><code class="objective-c">#include &lt;math.h&gt;
float __attribute__((overloadable)) tgsin(float x) { return sinf(x); }
double __attribute__((overloadable)) tgsin(double x) { return sin(x); }
long double __attribute__((overloadable)) tgsin(long double x) { return sinl(x); }
</code></pre>

<p>请注意<code>overloadable</code>只对函数起作用。你可以重载方法声明在某种范围内通过使用通用的返回值和参数类型，想<code>id</code>或者<code>void *</code>.</p>

<hr />

<p>上下文是国王当它遇到编译器优化时。通过提供限制在怎样解析你的代码，增加你参数尽可能高效代码的可能性。遇到编译器把你打断，这将是一项奖励。</p>

<p>还有<code>__attribute__</code>并不仅仅对编译器有用：下一个人看代码也将感谢这些额外的上下文。所以多走几英尺远将对你的合作中和接替者或者从现在算2年以后的你(那个时候你已经忘记了所以的事情关于这份代码)自己有用</p>

<p>你付出了多少爱,最终你会得到多少爱。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多线程之NSThread]]></title>
    <link href="http://wangruofeng.github.io/blog/2016/01/13/duo-xian-cheng-zhi-nsthread/"/>
    <updated>2016-01-13T03:35:48+08:00</updated>
    <id>http://wangruofeng.github.io/blog/2016/01/13/duo-xian-cheng-zhi-nsthread</id>
    <content type="html"><![CDATA[<h2>本文目录</h2>

<ul>
<li>前言</li>
<li>1.获取当前线程</li>
<li>2.获取主线程</li>
<li>3.NSThread的创建</li>
<li>4.暂停当前线程</li>
<li>5.线程的其他操作</li>
<li>6.优缺点</li>
</ul>


<h3>前言</h3>

<p>每个iOS应用程序都有个专门用来更新显示UI界面、处理用户触摸事件的主线程，因此不能将其他太耗时的操作放在主线程中执行，不然会造成主线程堵塞(出现卡机现象)，带来极坏的用户体验。一般的解决方案就是将那些耗时的操作放到另外一个线程中去执行，多线程编程是防止主线程堵塞，增加运行效率的最佳方法。</p>

<p>iOS中有3种常见的多线程编程方法
1. <code>NSThread</code>
这种方法需要管理线程的生命周期、同步、加锁问题，会导致一定的性能开销</p>

<ol>
<li><p><code>NSOperation</code>和<code>NSOperationQueue</code>
是基于OC实现的。NSOperation以面向对象的方式封装了需要执行的操作，然后可以将这个操作放到一个NSOperationQueue中去异步执行。不必关心线程管理、同步等问题。</p></li>
<li><p><code>Grand Centeral Dispatch</code>
简称GCD，iOS4才开始支持，是纯C语言的API。自iPad2开始，苹果设备开始有了双核CPU，为了充分利用这2个核，GCD提供了一些新特性来支持多核并行编程</p></li>
</ol>


<p>这篇文章简单介绍<code>NSThread这</code>个类，一个<code>NSThread</code>实例就代表着一条线程</p>

<h3>1.获取当前线程</h3>

<pre><code class="objective-c">    NSThread *current = [NSThread currentThread];
</code></pre>

<h3>2.获取主线程</h3>

<pre><code class="objective-c">    NSThread *main = [NSThread mainThread];
    NSLog(@"主线程:%@", main);    
</code></pre>

<p>打印结果是：</p>

<pre><code>2013-04-18 21:36:38.599 thread[7499:c07] 主线程:&lt;NSThread: 0x71434e0&gt;{name = (null), num = 1}
</code></pre>

<p>num相当于线程的id，主线程的num是为1的</p>

<h3>3.NSThread的创建</h3>

<h4>a.动态方法</h4>

<pre><code>- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;
</code></pre>

<p>在第2行创建了一条新线程，然后在第4行调用<code>start</code>方法启动线程，线程启动后会调用self的<code>run:</code>方法，并且将@&ldquo;mj"作为方法参数</p>

<pre><code class="objective-c">// 初始化线程
NSThread *thread = [[[NSThread alloc] initWithTarget:self selector:@selector(run:) object:@"mj"] autorelease];
// 开启线程
[thread start];
</code></pre>

<p>假如run:方法是这样的：</p>

<pre><code class="objective-c">- (void)run:(NSString *)string {
     NSThread *current = [NSThread currentThread];
     NSLog(@"执行了run:方法-参数：%@，当前线程：%@", string, current);
}
</code></pre>

<p>打印结果为：</p>

<pre><code>2013-04-18 21:40:33.102 thread[7542:3e13] 执行了run:方法-参数：mj，当前线程：&lt;NSThread: 0x889e8d0&gt;{name = (null), num = 3}
</code></pre>

<p>可以发现，这条线程的num值为3，说明不是主线程，主线程的num为1</p>

<h4>b.静态方法</h4>

<pre><code class="objective-c">    + (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;
</code></pre>

<pre><code class="objective-c">[NSThread detachNewThreadSelector:@selector(run:) toTarget:self withObject:@"mj"];
</code></pre>

<h4>c.隐式创建线程</h4>

<pre><code class="objective-c">[self performSelectorInBackground:@selector(run:) withObject:@"mj"];
</code></pre>

<p>会隐式地创建一条新线程，并且在这条线程上调用self的run:方法，以@&ldquo;mj"为方法参数</p>

<h3>4.暂停当前线程</h3>

<pre><code class="objective-c">    [NSThread sleepForTimeInterval:2];
</code></pre>

<pre><code class="objective-c">NSDate *date = [NSDate dateWithTimeInterval:2 sinceDate:[NSDate date]];  
[NSThread sleepUntilDate:date];
</code></pre>

<p>上面两种做法都是暂停当前线程2秒</p>

<h3>5.线程的其他操作</h3>

<h4>a.在指定线程上执行操作</h4>

<pre><code class="objective-c"> [self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES];
</code></pre>

<ul>
<li>上面代码的意思是在thread这条线程上调用self的run方法</li>
<li>最后的YES代表：上面的代码会阻塞，等run方法在thread线程执行完毕后，上面的代码才会通过</li>
</ul>


<h4>b.在主线程上执行操作</h4>

<pre><code class="objective-c">[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES];  
</code></pre>

<p>在主线程调用self的run方法</p>

<h4>c.在当前线程执行操作</h4>

<pre><code class="objective-c">[self performSelector:@selector(run) withObject:nil];
</code></pre>

<p>在当前线程调用self的run方法</p>

<h3>6.优缺点</h3>

<ol>
<li>优点：<code>NSThread</code>比其他多线程方案较轻量级，更直观地控制线程对象</li>
<li>缺点：需要自己管理线程的生命周期，线程同步。线程同步对数据的加锁会有一定的系统开销</li>
</ol>

]]></content>
  </entry>
  
</feed>
